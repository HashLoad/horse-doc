{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"English Horse O que \u00e9 o Horse? Horse \u00e9 um framework para aplica\u00e7\u00f5es web compat\u00edvel com Delphi e Lazarus. F\u00e1cil de ser adotada e integrada com outras bibliotecas ou projetos. Primeiros passos A melhor maneira de obter o Horse \u00e9 acessando a nossa P\u00e1gina de instala\u00e7\u00e3o . No\u00e7\u00f5es b\u00e1sicas O cora\u00e7\u00e3o do Horse \u00e9 um sistema que nos permite maper rotas HTTP de forma declarativa, com uma sintaxe muito simples. uses Horse ; begin THorse . Get ( '/ping' , procedure ( Req : THorseRequest ; Res : THorseResponse ; Next : TProc ) begin Res . Send ( 'pong' ) ; end ) ; THorse . Listen ( 9000 ) ; end . E n\u00f3s j\u00e1 criamos nosso primeiro servidor! Pronto para mais? Esta \u00e9 apenas uma breve introdu\u00e7\u00e3o do Horse. Continue o guia para se aprofundar em um maior n\u00famero de detalhes. Ent\u00e3o vamos l\u00e1! Veja mais: * Instalando Horse. * Implementando um Ol\u00e1 mundo! . * Entendendo rotas .","title":"Bem vindo"},{"location":"#horse","text":"","title":"Horse"},{"location":"#o-que-e-o-horse","text":"Horse \u00e9 um framework para aplica\u00e7\u00f5es web compat\u00edvel com Delphi e Lazarus. F\u00e1cil de ser adotada e integrada com outras bibliotecas ou projetos.","title":"O que \u00e9 o Horse?"},{"location":"#primeiros-passos","text":"A melhor maneira de obter o Horse \u00e9 acessando a nossa P\u00e1gina de instala\u00e7\u00e3o .","title":"Primeiros passos"},{"location":"#nocoes-basicas","text":"O cora\u00e7\u00e3o do Horse \u00e9 um sistema que nos permite maper rotas HTTP de forma declarativa, com uma sintaxe muito simples. uses Horse ; begin THorse . Get ( '/ping' , procedure ( Req : THorseRequest ; Res : THorseResponse ; Next : TProc ) begin Res . Send ( 'pong' ) ; end ) ; THorse . Listen ( 9000 ) ; end . E n\u00f3s j\u00e1 criamos nosso primeiro servidor!","title":"No\u00e7\u00f5es b\u00e1sicas"},{"location":"#pronto-para-mais","text":"Esta \u00e9 apenas uma breve introdu\u00e7\u00e3o do Horse. Continue o guia para se aprofundar em um maior n\u00famero de detalhes. Ent\u00e3o vamos l\u00e1! Veja mais: * Instalando Horse. * Implementando um Ol\u00e1 mundo! . * Entendendo rotas .","title":"Pronto para mais?"},{"location":"%23%20Diagramas/","text":"English: This page isn't translated to English. Diagramas graph TD; A-->B; A-->C; B-->D; C-->D; graph LR A[Square Rect] -- Link text --> B((Circle)) A --> C(Round Rect) B --> D{Rhombus} C --> D stateDiagram-v2 [ ] --> Still Still --> [ ] Still --> Moving Moving --> Still Moving --> Crash Crash --> [*] States A state can be declared in multiple ways. The simplest way is to define a state id as a description. stateDiagram-v2 s1 s1 Another way is by using the state keyword with a description as per below: stateDiagram-v2 state \"This is a state description\" as s2 This is a state description Another way to define a state with a description is to define the state id followed by a colon and the description: stateDiagram-v2 s2 : This is a state description This is a state description Transitions Transitions are path/edges when one state passes into another. This is represented using text arrow, \"-->\". When you define a transition between two states and the states are not already defined the undefined states are defined with the id from the transition. You can later add descriptions to states defined this way. stateDiagram-v2 s1 --> s2 s1 v s2 It is possible to add text to a transition. To describe what it represents. stateDiagram-v2 s1 --> s2: A transition s1 | A transition v s2 Start and End There are two special states indicating the start and stop of the diagram. These are written with the [*] syntax and the direction of the transition to it defines it either as a start or a stop state. stateDiagram-v2 [*] --> s1 s1 --> [*] (o)-->s1-->(o)","title":"Diagramas"},{"location":"%23%20Diagramas/#diagramas","text":"graph TD; A-->B; A-->C; B-->D; C-->D; graph LR A[Square Rect] -- Link text --> B((Circle)) A --> C(Round Rect) B --> D{Rhombus} C --> D stateDiagram-v2 [ ] --> Still Still --> [ ] Still --> Moving Moving --> Still Moving --> Crash Crash --> [*] States A state can be declared in multiple ways. The simplest way is to define a state id as a description. stateDiagram-v2 s1 s1 Another way is by using the state keyword with a description as per below: stateDiagram-v2 state \"This is a state description\" as s2 This is a state description Another way to define a state with a description is to define the state id followed by a colon and the description: stateDiagram-v2 s2 : This is a state description This is a state description Transitions Transitions are path/edges when one state passes into another. This is represented using text arrow, \"-->\". When you define a transition between two states and the states are not already defined the undefined states are defined with the id from the transition. You can later add descriptions to states defined this way. stateDiagram-v2 s1 --> s2 s1 v s2 It is possible to add text to a transition. To describe what it represents. stateDiagram-v2 s1 --> s2: A transition s1 | A transition v s2 Start and End There are two special states indicating the start and stop of the diagram. These are written with the [*] syntax and the direction of the transition to it defines it either as a start or a stop state. stateDiagram-v2 [*] --> s1 s1 --> [*] (o)-->s1-->(o)","title":"Diagramas"},{"location":"basic-routing.en/","text":"Portugu\u00eas Routing determines how the application will respond to a request from a client at an endpoint , which would be the URI and a specific method of the HTTP protocol (POST, PUT, GET, DELETE and so on). On the route, it is possible to have more than one treatment, which will be executed when the route that was requested is the corresponding one. The route has the following structure: THorse . METHOD ( PATH , HANDLER ) ; Where: METHOD is an HTTP request method. PATH it's a path on the server. HANDLER is the method (procedure) that will be executed when the route is matched. The following examples illustrate the definition of simple routes. Reply with \"Hello World!\" to whoever requested ( client who made the request ): GET POST PUT DELETE THorse . Get ( '/ping' , procedure ( Req : THorseRequest ; Res : THorseResponse ; Next : TProc ) begin Res . Send ( 'Hello World!' ) ; end ) ; Respond to POST request on the root route (/): THorse . Post ( '/' , procedure ( Req : THorseRequest ; Res : THorseResponse ; Next : TProc ) begin Res . Send ( 'Got a POST request' ) ; end ) ; Respond to a PUT request to the /user route THorse . Put ( '/user' , procedure ( Req : THorseRequest ; Res : THorseResponse ; Next : TProc ) begin Res . Send ( 'Got a PUT request at /user' ) ; end ) ; Respond to a DELETE request to the /user route THorse . Delete ( '/user' , procedure ( Req : THorseRequest ; Res : THorseResponse ; Next : TProc ) begin Res . Send ( 'Got a DELETE request at /user' ) ; end ) ;","title":"Routing"},{"location":"basic-routing/","text":"English Rotas determinam como a aplica\u00e7\u00e3o responder\u00e1 a uma requisi\u00e7\u00e3o do cliente em um caminho espec\u00edfico chamado endpoint , que \u00e9 uma URI que especifica um m\u00e9todo do protocolo HTTP (POST, PUT, GET, DELETE e al\u00e9m). Cada rota pode ter mais de um tratamento, que responder\u00e1 de acordo com a requisi\u00e7\u00e3o correspondente. Uma rota possui a seguinte estrutura THorse . METHOD ( PATH , HANDLER ) ; Onde: METHOD \u00e9 um m\u00e9todo HTTP . PATH \u00e9 o caminho no servidor. HANDLER \u00e9 um m\u00e9todo do delphi (procedure) quando esta rota for acessada. Os exemplos a seguir ilustram a defini\u00e7\u00e3o de rotas simples Reply with \"Hello World!\" to whoever requested ( client who made the request ): GET POST PUT DELETE THorse . Get ( '/ping' , procedure ( Req : THorseRequest ; Res : THorseResponse ; Next : TProc ) begin Res . Send ( 'Hello World!' ) ; end ) ; Respond to POST request on the root route (/): THorse . Post ( '/' , procedure ( Req : THorseRequest ; Res : THorseResponse ; Next : TProc ) begin Res . Send ( 'Got a POST request' ) ; end ) ; Respond to a PUT request to the /user route THorse . Put ( '/user' , procedure ( Req : THorseRequest ; Res : THorseResponse ; Next : TProc ) begin Res . Send ( 'Got a PUT request at /user' ) ; end ) ; Respond to a DELETE request to the /user route THorse . Delete ( '/user' , procedure ( Req : THorseRequest ; Res : THorseResponse ; Next : TProc ) begin Res . Send ( 'Got a DELETE request at /user' ) ; end ) ; NOTA: A vers\u00e3o atual do Lazarus 3.2.2 n\u00e3o tem suporte a m\u00e9todos an\u00f4nimos, veja o exemplo em Ol\u00e1 Mundo de como informar o callback no Lazarus","title":"Roteamento B\u00e1sico"},{"location":"hello-world.en/","text":"Portugu\u00eas Hello world! First create a console project in Delphi or Lazarus, save the project with the name you want (in this example, it will be saved as hashload_horse ). Then install Horse as a dependency on your project, according to the installation guide . After Horse is created and installed in your project, include the following code: Delphi Lazarus uses System . SysUtils , Horse ; const HORSE_PORT = 9000 ; begin THorse . Get ( '/' , procedure ( Req : THorseRequest ; Res : THorseResponse ; Next : TProc ) begin Res . Send ( 'Hello Word!' ) ; end ) ; THorse . Listen ( HORSE_PORT , procedure ( Horse : THorse ) begin Writeln ( Format ( 'Server is running on %s:%d' , [ Horse . Host , Horse . Port ])) ; end ) end . {$MODE DELPHI}{$H+} uses SysUtils , Horse ; const HORSE_PORT = 9000 ; procedure GetHelloWorld ( Req : THorseRequest ; Res : THorseResponse ; Next : TNextProc ) ; begin Res . Send ( 'Hello Word!' ) ; end ; procedure HorseListenCallback ( Horse : THorse ) ; begin Writeln ( Format ( 'Server is running on %s:%d' , [ Horse . Host , Horse . Port ])) ; end ; begin THorse . Get ( '/' , GetHelloWorld ) ; THorse . Listen ( HORSE_PORT , HorseListenCallback ) ; end . The application starts a server and listens for connections on port 9000. The application responds with a Hello, world! on the route (/) to the client that made the request . For all other paths, it will respond with a Not Found message and status code 404 Now, compile and run the application. You will have as a result on the console something like Server is running on 0.0.0.0:9000 Then open a browser, type http://localhost:9000/ in the address bar and browse to view the output. If you were able to view the result in your browser, this is great, your server worked correctly. Now you're ready to evolve on Horse! See more at: Understanding routing","title":"Hello world!"},{"location":"hello-world.en/#hello-world","text":"First create a console project in Delphi or Lazarus, save the project with the name you want (in this example, it will be saved as hashload_horse ). Then install Horse as a dependency on your project, according to the installation guide . After Horse is created and installed in your project, include the following code: Delphi Lazarus uses System . SysUtils , Horse ; const HORSE_PORT = 9000 ; begin THorse . Get ( '/' , procedure ( Req : THorseRequest ; Res : THorseResponse ; Next : TProc ) begin Res . Send ( 'Hello Word!' ) ; end ) ; THorse . Listen ( HORSE_PORT , procedure ( Horse : THorse ) begin Writeln ( Format ( 'Server is running on %s:%d' , [ Horse . Host , Horse . Port ])) ; end ) end . {$MODE DELPHI}{$H+} uses SysUtils , Horse ; const HORSE_PORT = 9000 ; procedure GetHelloWorld ( Req : THorseRequest ; Res : THorseResponse ; Next : TNextProc ) ; begin Res . Send ( 'Hello Word!' ) ; end ; procedure HorseListenCallback ( Horse : THorse ) ; begin Writeln ( Format ( 'Server is running on %s:%d' , [ Horse . Host , Horse . Port ])) ; end ; begin THorse . Get ( '/' , GetHelloWorld ) ; THorse . Listen ( HORSE_PORT , HorseListenCallback ) ; end . The application starts a server and listens for connections on port 9000. The application responds with a Hello, world! on the route (/) to the client that made the request . For all other paths, it will respond with a Not Found message and status code 404 Now, compile and run the application. You will have as a result on the console something like Server is running on 0.0.0.0:9000 Then open a browser, type http://localhost:9000/ in the address bar and browse to view the output. If you were able to view the result in your browser, this is great, your server worked correctly. Now you're ready to evolve on Horse! See more at: Understanding routing","title":"Hello world!"},{"location":"hello-world/","text":"English Ol\u00e1 mundo! Crie um projeto do tipo Console Application com o Delphi ou Lazarus, salve o seu projeto com o nome que voc\u00ea quiser (este exemplo foi salvo com o nome hashload_horse ). Ent\u00e3o instale o Horse e inclua nas depend\u00eancias do seu projeto, de acordo com o guia de instala\u00e7\u00e3o . Ap\u00f3s instalar o Horse e criar o seu projeto, inclua o seguinte c\u00f3digo: Delphi Lazarus uses System . SysUtils , Horse ; const HORSE_PORT = 9000 ; begin THorse . Get ( '/' , procedure ( Req : THorseRequest ; Res : THorseResponse ; Next : TProc ) begin Res . Send ( 'Ol\u00e1, mundo!' ) ; end ) ; THorse . Listen ( HORSE_PORT , procedure ( Horse : THorse ) begin Writeln ( Format ( 'O servidor est\u00e1 rodando em %s:%d' , [ Horse . Host , Horse . Port ])) ; end ) end . {$MODE DELPHI}{$H+} uses SysUtils , Horse ; const HORSE_PORT = 9000 ; procedure GetHelloWorld ( Req : THorseRequest ; Res : THorseResponse ; Next : TNextProc ) ; begin Res . Send ( 'Ola Mundo!' ) ; end ; procedure HorseListenCallback ( Horse : THorse ) ; begin Writeln ( Format ( 'O servidor esta rodando em %s:%d' , [ Horse . Host , Horse . Port ])) ; end ; begin THorse . Get ( '/' , GetHelloWorld ) ; THorse . Listen ( HORSE_PORT , HorseListenCallback ) ; end . A aplica\u00e7\u00e3o ir\u00e1 iniciar um servidor escutando na porta 9000. Agora, compile e rode a aplica\u00e7\u00e3o. Voc\u00ea ver\u00e1 no console a mensagem Servidor rodando em 0.0.0.0:9000 A Aplica\u00e7\u00e3o ir\u00e1 responder com a mensagem \"Ol\u00e1 Mundo\" na rota (/) para o cliente que fizer a requisi\u00e7\u00e3o . Para qualquer outra rota, ela ir\u00e1 responder com uma mensagem Not Found e status code 404 (N\u00e3o encontrado) Ent\u00e3o abra o browser, digite http://localhost:9000/ para acessar a sua primeira rota. Agora Voc\u00ea est\u00e1 pronto para desenvolver com o Horse! Pr\u00f3ximo passo: Entendendo rotas","title":"Ol\u00e1 mundo!"},{"location":"hello-world/#ola-mundo","text":"Crie um projeto do tipo Console Application com o Delphi ou Lazarus, salve o seu projeto com o nome que voc\u00ea quiser (este exemplo foi salvo com o nome hashload_horse ). Ent\u00e3o instale o Horse e inclua nas depend\u00eancias do seu projeto, de acordo com o guia de instala\u00e7\u00e3o . Ap\u00f3s instalar o Horse e criar o seu projeto, inclua o seguinte c\u00f3digo: Delphi Lazarus uses System . SysUtils , Horse ; const HORSE_PORT = 9000 ; begin THorse . Get ( '/' , procedure ( Req : THorseRequest ; Res : THorseResponse ; Next : TProc ) begin Res . Send ( 'Ol\u00e1, mundo!' ) ; end ) ; THorse . Listen ( HORSE_PORT , procedure ( Horse : THorse ) begin Writeln ( Format ( 'O servidor est\u00e1 rodando em %s:%d' , [ Horse . Host , Horse . Port ])) ; end ) end . {$MODE DELPHI}{$H+} uses SysUtils , Horse ; const HORSE_PORT = 9000 ; procedure GetHelloWorld ( Req : THorseRequest ; Res : THorseResponse ; Next : TNextProc ) ; begin Res . Send ( 'Ola Mundo!' ) ; end ; procedure HorseListenCallback ( Horse : THorse ) ; begin Writeln ( Format ( 'O servidor esta rodando em %s:%d' , [ Horse . Host , Horse . Port ])) ; end ; begin THorse . Get ( '/' , GetHelloWorld ) ; THorse . Listen ( HORSE_PORT , HorseListenCallback ) ; end . A aplica\u00e7\u00e3o ir\u00e1 iniciar um servidor escutando na porta 9000. Agora, compile e rode a aplica\u00e7\u00e3o. Voc\u00ea ver\u00e1 no console a mensagem Servidor rodando em 0.0.0.0:9000 A Aplica\u00e7\u00e3o ir\u00e1 responder com a mensagem \"Ol\u00e1 Mundo\" na rota (/) para o cliente que fizer a requisi\u00e7\u00e3o . Para qualquer outra rota, ela ir\u00e1 responder com uma mensagem Not Found e status code 404 (N\u00e3o encontrado) Ent\u00e3o abra o browser, digite http://localhost:9000/ para acessar a sua primeira rota. Agora Voc\u00ea est\u00e1 pronto para desenvolver com o Horse! Pr\u00f3ximo passo: Entendendo rotas","title":"Ol\u00e1 mundo!"},{"location":"index.en/","text":"Portugu\u00eas Horse What is Horse? Horse is a framework for building web applications in Delphi and Lazarus. As the main library, it is easy to adopt and integrate with other existing libraries or projects. First Steps The simplest way to test Horse is by installing. Feel free to install it and accompany us with some basic examples. In the topic Installation you will see how to install Horse. Basic Notions At the heart of Horse is a system that allows us to declaratively map HTTP routes using a very simple syntax: uses Horse ; begin THorse . Get ( '/ping' , procedure ( Req : THorseRequest ; Res : THorseResponse ; Next : TProc ) begin Res . Send ( 'pong' ) ; end ) ; THorse . Listen ( 9000 ) ; end . We just created our first Horse server! Ready for More? We introduced Horse briefly - the rest of this guide will delve into other advanced features in a much greater level of detail, so read on! See more at: * Installing Horse. * Creating a Hello world! . * Understanding routing . [URI]: Uniform Resource Identifier [HTTP]: Hypertext Transfer Protocol","title":"Welcome"},{"location":"index.en/#horse","text":"","title":"Horse"},{"location":"index.en/#what-is-horse","text":"Horse is a framework for building web applications in Delphi and Lazarus. As the main library, it is easy to adopt and integrate with other existing libraries or projects.","title":"What is Horse?"},{"location":"index.en/#first-steps","text":"The simplest way to test Horse is by installing. Feel free to install it and accompany us with some basic examples. In the topic Installation you will see how to install Horse.","title":"First Steps"},{"location":"index.en/#basic-notions","text":"At the heart of Horse is a system that allows us to declaratively map HTTP routes using a very simple syntax: uses Horse ; begin THorse . Get ( '/ping' , procedure ( Req : THorseRequest ; Res : THorseResponse ; Next : TProc ) begin Res . Send ( 'pong' ) ; end ) ; THorse . Listen ( 9000 ) ; end . We just created our first Horse server!","title":"Basic Notions"},{"location":"index.en/#ready-for-more","text":"We introduced Horse briefly - the rest of this guide will delve into other advanced features in a much greater level of detail, so read on! See more at: * Installing Horse. * Creating a Hello world! . * Understanding routing . [URI]: Uniform Resource Identifier [HTTP]: Hypertext Transfer Protocol","title":"Ready for More?"},{"location":"installation.en/","text":"Portugu\u00eas Boss The easiest and recommended way to install Horse is with Boss . With it you can manage the version of the dependencies used in your API, in addition to automatically configuring your project's * Library Path *. To perform the installation, simply open the terminal of your choice and enter the following commands: $ boss init $ boss install horse NOTE: it is worth mentioning that the command boss init is to initialize the dependency manager and must be executed only once. If you have already done so, there is no need to do it again. Manual Download the latest version of Horse and include the src/ folder in your project's Library Path . See more at: * Creating a Hello world! .","title":"Installation"},{"location":"installation.en/#boss","text":"The easiest and recommended way to install Horse is with Boss . With it you can manage the version of the dependencies used in your API, in addition to automatically configuring your project's * Library Path *. To perform the installation, simply open the terminal of your choice and enter the following commands: $ boss init $ boss install horse NOTE: it is worth mentioning that the command boss init is to initialize the dependency manager and must be executed only once. If you have already done so, there is no need to do it again.","title":"Boss"},{"location":"installation.en/#manual","text":"Download the latest version of Horse and include the src/ folder in your project's Library Path . See more at: * Creating a Hello world! .","title":"Manual"},{"location":"installation/","text":"English Boss A maneira mais f\u00e1cil de instalar o Horse \u00e9 utilizando o Boss (Recomendado) Esta ferramenta poder\u00e1 auxiliar a gerenciar pacotes de depend\u00eancias e vers\u00f5es utilizadas na sua api. Ela tamb\u00e9m ir\u00e1 configurar seu projeto automaticamente na * Library Path *. Para realizar a instala\u00e7\u00e3o, simplesmente abra o terminal de sua escolha e digite o seguinte comando: $ boss init $ boss install horse NOTA: O comando boss init serve para inicializar o gerenciador de depend\u00eancias e deve ser executado apenas uma vez. Se voc\u00ea j\u00e1 fez isso, n\u00e3o h\u00e1 necessidade de faz\u00ea-lo novamente. Manual Baixe a vers\u00e3o mais nova do Horse e inclua o diret\u00f3rio src/ na sua Library Path . Veja mais em: * Implementando um Ol\u00e1 Mundo! .","title":"Instala\u00e7\u00e3o"},{"location":"installation/#boss","text":"A maneira mais f\u00e1cil de instalar o Horse \u00e9 utilizando o Boss (Recomendado) Esta ferramenta poder\u00e1 auxiliar a gerenciar pacotes de depend\u00eancias e vers\u00f5es utilizadas na sua api. Ela tamb\u00e9m ir\u00e1 configurar seu projeto automaticamente na * Library Path *. Para realizar a instala\u00e7\u00e3o, simplesmente abra o terminal de sua escolha e digite o seguinte comando: $ boss init $ boss install horse NOTA: O comando boss init serve para inicializar o gerenciador de depend\u00eancias e deve ser executado apenas uma vez. Se voc\u00ea j\u00e1 fez isso, n\u00e3o h\u00e1 necessidade de faz\u00ea-lo novamente.","title":"Boss"},{"location":"installation/#manual","text":"Baixe a vers\u00e3o mais nova do Horse e inclua o diret\u00f3rio src/ na sua Library Path . Veja mais em: * Implementando um Ol\u00e1 Mundo! .","title":"Manual"},{"location":"missing-translations/","text":"English: This page isn't translated to English. es Espa\u00f1ol fr Fran\u00e7ais de Deutsche it Italiano ja Japanese !!! warning The current page still doesn't have a translation for those languages. But you can help translating it: [Contributing](https://github.com/HashLoad/horse-doc){.internal-link target=_blank}. Recommended Languages Tree /mkdocs.yml theme: languages: - en: /en/ # - az: /az/ # - de: /de/ # - es: /es/ # - fa: /fa/ # - fr: /fr/ # - id: /id/ # - it: /it/ # - ja: /ja/ # - ko: /ko/ # - nl: /nl/ # - pl: /pl/ - pt: /pt/ # - ru: /ru/ # - sq: /sq/ # - tr: /tr/ # - uk: /uk/ # - zh: /zh/ Recommended Languages Extra configuration ` /mkdocs.yml extra: alternate: - link: /en/ name: en - English # - link: /az/ # name: az # - link: /de/ # name: de # - link: /es/ # name: es - espa\u00f1ol # - link: /fa/ # name: fa # - link: /fr/ # name: fr - fran\u00e7ais # - link: /id/ # name: id # - link: /it/ # name: it - italiano # - link: /ja/ # name: ja - \u65e5\u672c\u8a9e # - link: /ko/ # name: ko - \ud55c\uad6d\uc5b4 # - link: /nl/ # name: nl # - link: /pl/ # name: pl - link: /pt/ name: pt - portugu\u00eas # - link: /ru/ # name: ru - \u0440\u0443\u0441\u0441\u043a\u0438\u0439 \u044f\u0437\u044b\u043a # - link: /sq/ # name: sq - shqip # - link: /tr/ # name: tr - T\u00fcrk\u00e7e # - link: /uk/ # name: uk - \u0443\u043a\u0440\u0430\u0457\u043d\u0441\u044c\u043a\u0430 \u043c\u043e\u0432\u0430 # - link: /zh/ # name: zh - \u6c49\u8bed","title":"Missing translations"},{"location":"routing/","text":"English: This page isn't translated to English. Roteamento O Roteamento \u00e9 o mecanismo pelo qual as requisi\u00e7\u00f5es s\u00e3o direcionadas para o c\u00f3digo que as trata. Para obter uma introdu\u00e7\u00e3o a roteamento, consulte Roteamento b\u00e1sico . O c\u00f3digo a seguir \u00e9 um exemplo de uma rota muito b\u00e1sica. uses Horse ; begin THorse . Get ( '/ping' , procedure ( Req : THorseRequest ; Res : THorseResponse ; Next : TProc ) begin Res . Send ( 'pong' ) ; end ) ; THorse . Listen ( 9000 ) ; end . M\u00e9todos de roteamento Um m\u00e9todo de roteamento \u00e9 derivado a partir de um dos m\u00e9todos HTTP , e \u00e9 anexado a uma procedure que ir\u00e1 tratar esta requisi\u00e7\u00e3o. o c\u00f3digo a seguir \u00e9 um exemplo de rotas para a raiz do aplicativo que est\u00e3o definidas para os m\u00e9todos GET e POST. uses Horse ; begin THorse . Get ( '/' , procedure ( Req : THorseRequest ; Res : THorseResponse ; Next : TProc ) begin Res . Send ( 'GET request to the root' ) ; end ) ; THorse . Post ( '/' , procedure ( Req : THorseRequest ; Res : THorseResponse ; Next : TProc ) begin Res . Send ( 'POST request to the root' ) ; end ) THorse . Listen ( 9000 ) ; end . O Horse suporta os seguintes m\u00e9todos de roteamento que correspondem aos m\u00e9todos HTTP : GET, POST, PUT, PATCH, HEAD, DELETE. Existe um m\u00e9todo de roteamento especial, THorse.All, que n\u00e3o \u00e9 derivado de nenhum m\u00e9todo HTTP . Este m\u00e9todo \u00e9 usado para carregar procedures em um caminho para todos os m\u00e9todos de solicita\u00e7\u00e3o. No exemplo a seguir, o manipulador ir\u00e1 ser executado para solicita\u00e7\u00f5es para \u201c/test\u201d se voc\u00ea estiver usando GET, POST, PUT, DELETE, ou qualquer outro m\u00e9todo de solicita\u00e7\u00e3o HTTP que \u00e9 suportado pelo Horse. THorse . All ( '/test' , procedure ( Req : THorseRequest ; Res : THorseResponse ; Next : TProc ) begin Res . Send ( 'Test Response' ) ; end ) ; M\u00e9todos de resposta Os m\u00e9todos do objeto de resposta (res) na seguinte tabela podem enviar uma resposta ao cliente, e finalizar o ciclo solicita\u00e7\u00e3o-resposta. M\u00e9todo Descri\u00e7\u00e3o Res.Download(AFileName) Solicita que seja efetuado o download de um arquivo Res.RedirectTo(ALocation) Redireciona uma solicita\u00e7\u00e3o Res.SendFile(AFileName) Envia um arquivo Res.Send(AContent) Envia uma string Res.Send Envia um objeto Res.Status(AStatus) Configura o c\u00f3digo do status de resposta Res.ContentType(AContentType) Configura o ContentType da resposta","title":"Roteamento"},{"location":"routing/#roteamento","text":"O Roteamento \u00e9 o mecanismo pelo qual as requisi\u00e7\u00f5es s\u00e3o direcionadas para o c\u00f3digo que as trata. Para obter uma introdu\u00e7\u00e3o a roteamento, consulte Roteamento b\u00e1sico . O c\u00f3digo a seguir \u00e9 um exemplo de uma rota muito b\u00e1sica. uses Horse ; begin THorse . Get ( '/ping' , procedure ( Req : THorseRequest ; Res : THorseResponse ; Next : TProc ) begin Res . Send ( 'pong' ) ; end ) ; THorse . Listen ( 9000 ) ; end .","title":"Roteamento"},{"location":"routing/#metodos-de-roteamento","text":"Um m\u00e9todo de roteamento \u00e9 derivado a partir de um dos m\u00e9todos HTTP , e \u00e9 anexado a uma procedure que ir\u00e1 tratar esta requisi\u00e7\u00e3o. o c\u00f3digo a seguir \u00e9 um exemplo de rotas para a raiz do aplicativo que est\u00e3o definidas para os m\u00e9todos GET e POST. uses Horse ; begin THorse . Get ( '/' , procedure ( Req : THorseRequest ; Res : THorseResponse ; Next : TProc ) begin Res . Send ( 'GET request to the root' ) ; end ) ; THorse . Post ( '/' , procedure ( Req : THorseRequest ; Res : THorseResponse ; Next : TProc ) begin Res . Send ( 'POST request to the root' ) ; end ) THorse . Listen ( 9000 ) ; end . O Horse suporta os seguintes m\u00e9todos de roteamento que correspondem aos m\u00e9todos HTTP : GET, POST, PUT, PATCH, HEAD, DELETE. Existe um m\u00e9todo de roteamento especial, THorse.All, que n\u00e3o \u00e9 derivado de nenhum m\u00e9todo HTTP . Este m\u00e9todo \u00e9 usado para carregar procedures em um caminho para todos os m\u00e9todos de solicita\u00e7\u00e3o. No exemplo a seguir, o manipulador ir\u00e1 ser executado para solicita\u00e7\u00f5es para \u201c/test\u201d se voc\u00ea estiver usando GET, POST, PUT, DELETE, ou qualquer outro m\u00e9todo de solicita\u00e7\u00e3o HTTP que \u00e9 suportado pelo Horse. THorse . All ( '/test' , procedure ( Req : THorseRequest ; Res : THorseResponse ; Next : TProc ) begin Res . Send ( 'Test Response' ) ; end ) ;","title":"M\u00e9todos de roteamento"},{"location":"routing/#metodos-de-resposta","text":"Os m\u00e9todos do objeto de resposta (res) na seguinte tabela podem enviar uma resposta ao cliente, e finalizar o ciclo solicita\u00e7\u00e3o-resposta. M\u00e9todo Descri\u00e7\u00e3o Res.Download(AFileName) Solicita que seja efetuado o download de um arquivo Res.RedirectTo(ALocation) Redireciona uma solicita\u00e7\u00e3o Res.SendFile(AFileName) Envia um arquivo Res.Send(AContent) Envia uma string Res.Send Envia um objeto Res.Status(AStatus) Configura o c\u00f3digo do status de resposta Res.ContentType(AContentType) Configura o ContentType da resposta","title":"M\u00e9todos de resposta"}]}