{"config":{"indexing":"full","lang":["en","pt"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Horse O Horse \u00e9 um framework web, r\u00e1pido e minimalista para constru\u00e7\u00e3o de API REST baseado no framework Express do Nodejs compativel com o Delphi e Lazarus. Sua arquitetura modular e estruturada em princ\u00edpios como o SOLID, permite que sua aplica\u00e7\u00e3o seja flex\u00edvel com uma infinidade de middlewares a seu dispor, fazendo com que a sua API contenha apenas os recursos que forem essenciais para o seu funcionamento. IDE : #delphi #lazarus Aplica\u00e7\u00f5es : #console #apache #isapi #cgi #daemon #fastcgi #windowsService #vcl Plataformas : #windows #linux #docker #\ufe0f\u20e3 Hashload A Hashload \u00e9 uma comunidade open-source no GitHub, mantenedora de projetos como o Horse e o Boss. O objetivo principal da comunidade \u00e9 fomentar e incentivar projetos de c\u00f3digo aberto, carentes na comunidade Delphi e Lazarus. \ud83e\uddec Middlewares oficiais Para um ecosistema mais organizado e modular, colocamos nossos middlewares oficiais em reposit\u00f3rios separados: Middleware Delphi Lazarus horse/json \u2714\ufe0f \u2714\ufe0f horse/basic-auth \u2714\ufe0f \u2714\ufe0f horse/cors \u2714\ufe0f \u2714\ufe0f horse/stream \u2714\ufe0f \u2714\ufe0f horse/jwt \u2714\ufe0f \u2714\ufe0f horse/exception \u2714\ufe0f \u2714\ufe0f horse/logger \u2714\ufe0f \u2714\ufe0f horse/compression \u2714\ufe0f \u2714\ufe0f \ud83c\udf31 Middlewares de terceiros Esta \u00e9 uma lista de middlewares que s\u00e3o criados pela comunidade Horse. Se voc\u00ea criou um middleware tamb\u00e9m, e deseja que ele apare\u00e7a na lista abaixo, por favor nos envie um pull request ! Middleware Delphi Lazarus bittencourtthulio/etag \u2714\ufe0f \u2714\ufe0f bittencourtthulio/paginate \u2714\ufe0f \u2714\ufe0f bittencourtthulio/cachecontrol \u2714\ufe0f \u274c gabrielbaltazar/gbswagger \u2714\ufe0f \u274c willhubner/socketIO \u2714\ufe0f \u274c dliocode/ratelimit \u2714\ufe0f \u274c dliocode/slowdown \u2714\ufe0f \u274c giorgiobazzo/upload \u2714\ufe0f \u274c dliocode/query \u2714\ufe0f \u274c CarlosHe/healthcheck \u2714\ufe0f \u274c CarlosHe/staticfiles \u2714\ufe0f \u274c CachopaWeb/horse-server-static \u2714\ufe0f \u274c arvanus/horse-exception-logger \u2714\ufe0f \u2714\ufe0f claudneysessa/Horse-CSResponsePagination \u2714\ufe0f \u274c claudneysessa/Horse-XSuperObjects \u2714\ufe0f \u274c andre-djsystem/horse-bearer-auth \u2714\ufe0f \u2714\ufe0f andre-djsystem/horse-manipulate-request \u2714\ufe0f \u2714\ufe0f andre-djsystem/horse-manipulate-response \u2714\ufe0f \u2714\ufe0f antoniojmsjr/Horse-IPGeoLocation \u2714\ufe0f \u274c \u26a0\ufe0f Compatibilidade Se voc\u00ea estiver interessado em utilizar o Horse no Delphi, informamos que a vers\u00e3o m\u00ednima compat\u00edvel com o Horse \u00e9 o Delphi XE7. Todas as vers\u00f5es superiores possuem compatibilidade com o framework Horse*. Caso esteja interessado em utilizar o Horse no Lazazrus, recomendamos sempre que utilize a \u00faltima vers\u00e3o dispon\u00edvel, visto que \u00e9 uma IDE grat\u00faita e n\u00e3o tem custos com a atualiza\u00e7\u00e3o da mesma.","title":"Bem vindo"},{"location":"#horse","text":"O Horse \u00e9 um framework web, r\u00e1pido e minimalista para constru\u00e7\u00e3o de API REST baseado no framework Express do Nodejs compativel com o Delphi e Lazarus. Sua arquitetura modular e estruturada em princ\u00edpios como o SOLID, permite que sua aplica\u00e7\u00e3o seja flex\u00edvel com uma infinidade de middlewares a seu dispor, fazendo com que a sua API contenha apenas os recursos que forem essenciais para o seu funcionamento. IDE : #delphi #lazarus Aplica\u00e7\u00f5es : #console #apache #isapi #cgi #daemon #fastcgi #windowsService #vcl Plataformas : #windows #linux #docker","title":"Horse"},{"location":"#hashload","text":"A Hashload \u00e9 uma comunidade open-source no GitHub, mantenedora de projetos como o Horse e o Boss. O objetivo principal da comunidade \u00e9 fomentar e incentivar projetos de c\u00f3digo aberto, carentes na comunidade Delphi e Lazarus.","title":"#\ufe0f\u20e3 Hashload"},{"location":"#middlewares-oficiais","text":"Para um ecosistema mais organizado e modular, colocamos nossos middlewares oficiais em reposit\u00f3rios separados: Middleware Delphi Lazarus horse/json \u2714\ufe0f \u2714\ufe0f horse/basic-auth \u2714\ufe0f \u2714\ufe0f horse/cors \u2714\ufe0f \u2714\ufe0f horse/stream \u2714\ufe0f \u2714\ufe0f horse/jwt \u2714\ufe0f \u2714\ufe0f horse/exception \u2714\ufe0f \u2714\ufe0f horse/logger \u2714\ufe0f \u2714\ufe0f horse/compression \u2714\ufe0f \u2714\ufe0f","title":"\ud83e\uddec Middlewares oficiais"},{"location":"#middlewares-de-terceiros","text":"Esta \u00e9 uma lista de middlewares que s\u00e3o criados pela comunidade Horse. Se voc\u00ea criou um middleware tamb\u00e9m, e deseja que ele apare\u00e7a na lista abaixo, por favor nos envie um pull request ! Middleware Delphi Lazarus bittencourtthulio/etag \u2714\ufe0f \u2714\ufe0f bittencourtthulio/paginate \u2714\ufe0f \u2714\ufe0f bittencourtthulio/cachecontrol \u2714\ufe0f \u274c gabrielbaltazar/gbswagger \u2714\ufe0f \u274c willhubner/socketIO \u2714\ufe0f \u274c dliocode/ratelimit \u2714\ufe0f \u274c dliocode/slowdown \u2714\ufe0f \u274c giorgiobazzo/upload \u2714\ufe0f \u274c dliocode/query \u2714\ufe0f \u274c CarlosHe/healthcheck \u2714\ufe0f \u274c CarlosHe/staticfiles \u2714\ufe0f \u274c CachopaWeb/horse-server-static \u2714\ufe0f \u274c arvanus/horse-exception-logger \u2714\ufe0f \u2714\ufe0f claudneysessa/Horse-CSResponsePagination \u2714\ufe0f \u274c claudneysessa/Horse-XSuperObjects \u2714\ufe0f \u274c andre-djsystem/horse-bearer-auth \u2714\ufe0f \u2714\ufe0f andre-djsystem/horse-manipulate-request \u2714\ufe0f \u2714\ufe0f andre-djsystem/horse-manipulate-response \u2714\ufe0f \u2714\ufe0f antoniojmsjr/Horse-IPGeoLocation \u2714\ufe0f \u274c","title":"\ud83c\udf31 Middlewares de terceiros"},{"location":"#compatibilidade","text":"Se voc\u00ea estiver interessado em utilizar o Horse no Delphi, informamos que a vers\u00e3o m\u00ednima compat\u00edvel com o Horse \u00e9 o Delphi XE7. Todas as vers\u00f5es superiores possuem compatibilidade com o framework Horse*. Caso esteja interessado em utilizar o Horse no Lazazrus, recomendamos sempre que utilize a \u00faltima vers\u00e3o dispon\u00edvel, visto que \u00e9 uma IDE grat\u00faita e n\u00e3o tem custos com a atualiza\u00e7\u00e3o da mesma.","title":"\u26a0\ufe0f Compatibilidade"},{"location":"%23%20Diagramas/","text":"Diagramas graph TD; A-->B; A-->C; B-->D; C-->D; graph LR A[Square Rect] -- Link text --> B((Circle)) A --> C(Round Rect) B --> D{Rhombus} C --> D stateDiagram-v2 [ ] --> Still Still --> [ ] Still --> Moving Moving --> Still Moving --> Crash Crash --> [*] States A state can be declared in multiple ways. The simplest way is to define a state id as a description. stateDiagram-v2 s1 s1 Another way is by using the state keyword with a description as per below: stateDiagram-v2 state \"This is a state description\" as s2 This is a state description Another way to define a state with a description is to define the state id followed by a colon and the description: stateDiagram-v2 s2 : This is a state description This is a state description Transitions Transitions are path/edges when one state passes into another. This is represented using text arrow, \"-->\". When you define a transition between two states and the states are not already defined the undefined states are defined with the id from the transition. You can later add descriptions to states defined this way. stateDiagram-v2 s1 --> s2 s1 v s2 It is possible to add text to a transition. To describe what it represents. stateDiagram-v2 s1 --> s2: A transition s1 | A transition v s2 Start and End There are two special states indicating the start and stop of the diagram. These are written with the [*] syntax and the direction of the transition to it defines it either as a start or a stop state. stateDiagram-v2 [*] --> s1 s1 --> [*] (o)-->s1-->(o)","title":"Diagramas"},{"location":"%23%20Diagramas/#diagramas","text":"graph TD; A-->B; A-->C; B-->D; C-->D; graph LR A[Square Rect] -- Link text --> B((Circle)) A --> C(Round Rect) B --> D{Rhombus} C --> D stateDiagram-v2 [ ] --> Still Still --> [ ] Still --> Moving Moving --> Still Moving --> Crash Crash --> [*] States A state can be declared in multiple ways. The simplest way is to define a state id as a description. stateDiagram-v2 s1 s1 Another way is by using the state keyword with a description as per below: stateDiagram-v2 state \"This is a state description\" as s2 This is a state description Another way to define a state with a description is to define the state id followed by a colon and the description: stateDiagram-v2 s2 : This is a state description This is a state description Transitions Transitions are path/edges when one state passes into another. This is represented using text arrow, \"-->\". When you define a transition between two states and the states are not already defined the undefined states are defined with the id from the transition. You can later add descriptions to states defined this way. stateDiagram-v2 s1 --> s2 s1 v s2 It is possible to add text to a transition. To describe what it represents. stateDiagram-v2 s1 --> s2: A transition s1 | A transition v s2 Start and End There are two special states indicating the start and stop of the diagram. These are written with the [*] syntax and the direction of the transition to it defines it either as a start or a stop state. stateDiagram-v2 [*] --> s1 s1 --> [*] (o)-->s1-->(o)","title":"Diagramas"},{"location":"basic-routing/","text":"Rotas determinam como a aplica\u00e7\u00e3o responder\u00e1 a uma requisi\u00e7\u00e3o do cliente em um caminho espec\u00edfico chamado endpoint , que \u00e9 uma URI que especifica um m\u00e9todo do protocolo HTTP (POST, PUT, GET, DELETE e al\u00e9m). Cada rota pode ter mais de um tratamento, que responder\u00e1 de acordo com a requisi\u00e7\u00e3o correspondente. Estrutura Uma rota possui a seguinte estrutura: THorse . METHOD ( PATH , HANDLER ) ; Onde: THorse \u00e9 a instancia atual do Horse; METHOD \u00e9 um m\u00e9todo do protocolo HTTP ; PATH \u00e9 um caminho no servidor; HANDLER \u00e9 a fun\u00e7\u00e3o que ser\u00e1 executada quando a rota for acessada; Exemplos Os exemplos a seguir ilustram a defini\u00e7\u00e3o de rotas simples: Responder a uma requisi\u00e7\u00e3o GET para a rota /users : Delphi Lazarus THorse . Get ( '/users' , procedure ( Req : THorseRequest ; Res : THorseResponse ; Next : TProc ) begin Res . Send ( 'GET Users' ) ; end ) ; procedure DoGetUsers ( Req : THorseRequest ; Res : THorseResponse ; Next : TNextProc ) ; begin Res . Send ( 'GET Users' ) ; end ; begin THorse . Get ( '/users' , DoGetUsers ) ; end . Responder a uma requisi\u00e7\u00e3o POST para a rota /users : Delphi Lazarus THorse . Post ( '/users' , procedure ( Req : THorseRequest ; Res : THorseResponse ; Next : TProc ) begin Res . Send ( 'POST Users' ) ; end ) ; procedure DoPostUsers ( Req : THorseRequest ; Res : THorseResponse ; Next : TNextProc ) ; begin Res . Send ( 'POST Users' ) ; end ; begin THorse . Post ( '/users' , DoPostUsers ) ; end . Responder a uma requisi\u00e7\u00e3o PUT para a rota /users/:id : Delphi Lazarus THorse . Put ( '/users/:id' , procedure ( Req : THorseRequest ; Res : THorseResponse ; Next : TProc ) begin Res . Send ( 'PUT Users' ) ; end ) ; procedure DoPutUser ( Req : THorseRequest ; Res : THorseResponse ; Next : TNextProc ) ; begin Res . Send ( 'PUT Users' ) ; end ; begin THorse . Put ( '/users/:id' , DoPutUser ) ; end . Responder a uma requisi\u00e7\u00e3o DELETE para a rota /users/:id : Delphi Lazarus THorse . Delete ( '/users/:id' , procedure ( Req : THorseRequest ; Res : THorseResponse ; Next : TProc ) begin Res . Send ( 'DELETE Users' ) ; end ) ; procedure DoDeleteUser ( Req : THorseRequest ; Res : THorseResponse ; Next : TNextProc ) ; begin Res . Send ( 'DELETE Users' ) ; end ; begin THorse . Delete ( '/users/:id' , DoDeleteUser ) ; end .","title":"Roteamento B\u00e1sico"},{"location":"basic-routing/#estrutura","text":"Uma rota possui a seguinte estrutura: THorse . METHOD ( PATH , HANDLER ) ; Onde: THorse \u00e9 a instancia atual do Horse; METHOD \u00e9 um m\u00e9todo do protocolo HTTP ; PATH \u00e9 um caminho no servidor; HANDLER \u00e9 a fun\u00e7\u00e3o que ser\u00e1 executada quando a rota for acessada;","title":"Estrutura"},{"location":"basic-routing/#exemplos","text":"Os exemplos a seguir ilustram a defini\u00e7\u00e3o de rotas simples: Responder a uma requisi\u00e7\u00e3o GET para a rota /users : Delphi Lazarus THorse . Get ( '/users' , procedure ( Req : THorseRequest ; Res : THorseResponse ; Next : TProc ) begin Res . Send ( 'GET Users' ) ; end ) ; procedure DoGetUsers ( Req : THorseRequest ; Res : THorseResponse ; Next : TNextProc ) ; begin Res . Send ( 'GET Users' ) ; end ; begin THorse . Get ( '/users' , DoGetUsers ) ; end . Responder a uma requisi\u00e7\u00e3o POST para a rota /users : Delphi Lazarus THorse . Post ( '/users' , procedure ( Req : THorseRequest ; Res : THorseResponse ; Next : TProc ) begin Res . Send ( 'POST Users' ) ; end ) ; procedure DoPostUsers ( Req : THorseRequest ; Res : THorseResponse ; Next : TNextProc ) ; begin Res . Send ( 'POST Users' ) ; end ; begin THorse . Post ( '/users' , DoPostUsers ) ; end . Responder a uma requisi\u00e7\u00e3o PUT para a rota /users/:id : Delphi Lazarus THorse . Put ( '/users/:id' , procedure ( Req : THorseRequest ; Res : THorseResponse ; Next : TProc ) begin Res . Send ( 'PUT Users' ) ; end ) ; procedure DoPutUser ( Req : THorseRequest ; Res : THorseResponse ; Next : TNextProc ) ; begin Res . Send ( 'PUT Users' ) ; end ; begin THorse . Put ( '/users/:id' , DoPutUser ) ; end . Responder a uma requisi\u00e7\u00e3o DELETE para a rota /users/:id : Delphi Lazarus THorse . Delete ( '/users/:id' , procedure ( Req : THorseRequest ; Res : THorseResponse ; Next : TProc ) begin Res . Send ( 'DELETE Users' ) ; end ) ; procedure DoDeleteUser ( Req : THorseRequest ; Res : THorseResponse ; Next : TNextProc ) ; begin Res . Send ( 'DELETE Users' ) ; end ; begin THorse . Delete ( '/users/:id' , DoDeleteUser ) ; end .","title":"Exemplos"},{"location":"hello-world/","text":"Ol\u00e1 mundo! Independente da IDE que estiver utilizando, crie um projeto do tipo Console Application e salve o projeto com o nome que voc\u00ea quiser. Ap\u00f3s salvar o projeto, siga o guia de instala\u00e7\u00e3o para instalar o Horse na sua aplica\u00e7\u00e3o. Ap\u00f3s criar o seu projeto e instalar o Horse, inclua o seguinte c\u00f3digo em sua aplica\u00e7\u00e3o: Delphi Lazarus uses System . SysUtils , Horse ; const HORSE_PORT = 9000 ; begin THorse . Get ( '/' , procedure ( Req : THorseRequest ; Res : THorseResponse ; Next : TProc ) begin Res . Send ( 'Ol\u00e1, mundo!' ) ; end ) ; THorse . Listen ( HORSE_PORT , procedure ( Horse : THorse ) begin Writeln ( Format ( 'O servidor est\u00e1 rodando em %s:%d' , [ Horse . Host , Horse . Port ])) ; end ) ; end . {$MODE DELPHI}{$H+} uses SysUtils , Horse ; const HORSE_PORT = 9000 ; procedure GetHelloWorld ( Req : THorseRequest ; Res : THorseResponse ; Next : TNextProc ) ; begin Res . Send ( 'Ola Mundo!' ) ; end ; procedure HorseListenCallback ( Horse : THorse ) ; begin Writeln ( Format ( 'O servidor esta rodando em %s:%d' , [ Horse . Host , Horse . Port ])) ; end ; begin THorse . Get ( '/' , GetHelloWorld ) ; THorse . Listen ( HORSE_PORT , HorseListenCallback ) ; end . A aplica\u00e7\u00e3o ir\u00e1 iniciar um servidor escutando na porta 9000. Agora, compile e rode a aplica\u00e7\u00e3o. Voc\u00ea ver\u00e1 no console a seguinte mensagem: Servidor rodando em 0.0.0.0:9000 A Aplica\u00e7\u00e3o ir\u00e1 responder com a mensagem \"Ol\u00e1 Mundo\" na rota (/) para o cliente que fizer a requisi\u00e7\u00e3o . Para qualquer outra rota, ela ir\u00e1 responder com uma mensagem \"Not Found\" e status code 404 (N\u00e3o encontrado) Ent\u00e3o abra o browser, digite http://localhost:9000/ para acessar a sua primeira rota. Simplificando Caso n\u00e3o tenha necessidade de printar alguma mensagem no console, ou ent\u00e3o n\u00e3o quer alterar a porta padr\u00e3o utilizada pelo Horse, pode simplificar ainda mais o c\u00f3digo, deixando da seguinte forma: Delphi Lazarus uses Horse ; begin THorse . Get ( '/' , procedure ( Req : THorseRequest ; Res : THorseResponse ; Next : TProc ) begin Res . Send ( 'Ol\u00e1, mundo!' ) ; end ) ; THorse . Listen ; end . {$MODE DELPHI}{$H+} uses Horse ; procedure GetHelloWorld ( Req : THorseRequest ; Res : THorseResponse ; Next : TNextProc ) ; begin Res . Send ( 'Ola Mundo!' ) ; end ; begin THorse . Get ( '/' , GetHelloWorld ) ; THorse . Listen ; end . Pronto! Agora voc\u00ea est\u00e1 h\u00e1pto para trabalhar com o Horse...","title":"Ol\u00e1 mundo!"},{"location":"hello-world/#ola-mundo","text":"Independente da IDE que estiver utilizando, crie um projeto do tipo Console Application e salve o projeto com o nome que voc\u00ea quiser. Ap\u00f3s salvar o projeto, siga o guia de instala\u00e7\u00e3o para instalar o Horse na sua aplica\u00e7\u00e3o. Ap\u00f3s criar o seu projeto e instalar o Horse, inclua o seguinte c\u00f3digo em sua aplica\u00e7\u00e3o: Delphi Lazarus uses System . SysUtils , Horse ; const HORSE_PORT = 9000 ; begin THorse . Get ( '/' , procedure ( Req : THorseRequest ; Res : THorseResponse ; Next : TProc ) begin Res . Send ( 'Ol\u00e1, mundo!' ) ; end ) ; THorse . Listen ( HORSE_PORT , procedure ( Horse : THorse ) begin Writeln ( Format ( 'O servidor est\u00e1 rodando em %s:%d' , [ Horse . Host , Horse . Port ])) ; end ) ; end . {$MODE DELPHI}{$H+} uses SysUtils , Horse ; const HORSE_PORT = 9000 ; procedure GetHelloWorld ( Req : THorseRequest ; Res : THorseResponse ; Next : TNextProc ) ; begin Res . Send ( 'Ola Mundo!' ) ; end ; procedure HorseListenCallback ( Horse : THorse ) ; begin Writeln ( Format ( 'O servidor esta rodando em %s:%d' , [ Horse . Host , Horse . Port ])) ; end ; begin THorse . Get ( '/' , GetHelloWorld ) ; THorse . Listen ( HORSE_PORT , HorseListenCallback ) ; end . A aplica\u00e7\u00e3o ir\u00e1 iniciar um servidor escutando na porta 9000. Agora, compile e rode a aplica\u00e7\u00e3o. Voc\u00ea ver\u00e1 no console a seguinte mensagem: Servidor rodando em 0.0.0.0:9000 A Aplica\u00e7\u00e3o ir\u00e1 responder com a mensagem \"Ol\u00e1 Mundo\" na rota (/) para o cliente que fizer a requisi\u00e7\u00e3o . Para qualquer outra rota, ela ir\u00e1 responder com uma mensagem \"Not Found\" e status code 404 (N\u00e3o encontrado) Ent\u00e3o abra o browser, digite http://localhost:9000/ para acessar a sua primeira rota.","title":"Ol\u00e1 mundo!"},{"location":"hello-world/#simplificando","text":"Caso n\u00e3o tenha necessidade de printar alguma mensagem no console, ou ent\u00e3o n\u00e3o quer alterar a porta padr\u00e3o utilizada pelo Horse, pode simplificar ainda mais o c\u00f3digo, deixando da seguinte forma: Delphi Lazarus uses Horse ; begin THorse . Get ( '/' , procedure ( Req : THorseRequest ; Res : THorseResponse ; Next : TProc ) begin Res . Send ( 'Ol\u00e1, mundo!' ) ; end ) ; THorse . Listen ; end . {$MODE DELPHI}{$H+} uses Horse ; procedure GetHelloWorld ( Req : THorseRequest ; Res : THorseResponse ; Next : TNextProc ) ; begin Res . Send ( 'Ola Mundo!' ) ; end ; begin THorse . Get ( '/' , GetHelloWorld ) ; THorse . Listen ; end . Pronto! Agora voc\u00ea est\u00e1 h\u00e1pto para trabalhar com o Horse...","title":"Simplificando"},{"location":"installation/","text":"Atualmente existem duas formas de instalar o Horse. Voc\u00ea pode fazer a instala\u00e7\u00e3o de forma manual, ou pode optar por utilizar o Boss que \u00e9 um gerenciador de depend\u00eancias para aplica\u00e7\u00f5es desenvolvidas com Delphi e Lazarus. Pelo fato do Horse ser um projeto modular, onde vamos trabalhar com v\u00e1rios pacotes ou depend\u00eancias pequenas que ser\u00e3o acopladas ao nosso projeto (tamb\u00e9m chamados de middlewares), recomendamos a utiliza\u00e7\u00e3o do Boss para realizar a instala\u00e7\u00e3o. Boss Antes de continuar, \u00e9 necess\u00e1rio que voc\u00ea tenha o Boss instalado em sua m\u00e1quina. Para isso basta realizar o download da \u00faltima vers\u00e3o dispon\u00edvel do gerenciador clicando aqui A instala\u00e7\u00e3o \u00e9 bem simples, e resume-se apenas em \"next\". Ao final de tudo, voc\u00ea pode conferir se o boss foi instalado executando o comando boss version em um terminal, onde o resultado deve ser algo semelhante ao exemplo abaixo: $ boss version 3 .0.5 O pr\u00f3ximo passo \u00e9 voc\u00ea inicializar o boss na sua aplica\u00e7\u00e3o. Esse processo deve ser feito uma \u00fanica vez por projeto para que seja criado os arquivos boss.json e boss-lock.json . Para isso, execute o seguinte comando em um terminal: $ boss init Pronto! Com o boss inicializado na sua aplica\u00e7\u00e3o, basta realizar a instala\u00e7\u00e3o do Horse com o seguinte comando: $ boss install horse Instala\u00e7\u00e3o manual Embora esta n\u00e3o seja a op\u00e7\u00e3o de instala\u00e7\u00e3o recomendada, tamb\u00e9m \u00e9 poss\u00edvel instalar o Horse de forma manual. Para isso, basta realizar o download do Horse clicando aqui . Se voc\u00ea estiver utilizando o Delphi, o pr\u00f3ximo passo \u00e9 adicionar no Library Path da sua IDE ou em Project > Options > Resource Compiler > Directories and Conditionals > Include file search path do seu projeto, o diret\u00f3rio horse/src . No Lazarus voc\u00ea pode adicionar o diret\u00f3rio horse/src em Project > Project Options > Compiler Options > Path > Other unit files do seu projeto.","title":"Instala\u00e7\u00e3o"},{"location":"installation/#boss","text":"Antes de continuar, \u00e9 necess\u00e1rio que voc\u00ea tenha o Boss instalado em sua m\u00e1quina. Para isso basta realizar o download da \u00faltima vers\u00e3o dispon\u00edvel do gerenciador clicando aqui A instala\u00e7\u00e3o \u00e9 bem simples, e resume-se apenas em \"next\". Ao final de tudo, voc\u00ea pode conferir se o boss foi instalado executando o comando boss version em um terminal, onde o resultado deve ser algo semelhante ao exemplo abaixo: $ boss version 3 .0.5 O pr\u00f3ximo passo \u00e9 voc\u00ea inicializar o boss na sua aplica\u00e7\u00e3o. Esse processo deve ser feito uma \u00fanica vez por projeto para que seja criado os arquivos boss.json e boss-lock.json . Para isso, execute o seguinte comando em um terminal: $ boss init Pronto! Com o boss inicializado na sua aplica\u00e7\u00e3o, basta realizar a instala\u00e7\u00e3o do Horse com o seguinte comando: $ boss install horse","title":"Boss"},{"location":"installation/#instalacao-manual","text":"Embora esta n\u00e3o seja a op\u00e7\u00e3o de instala\u00e7\u00e3o recomendada, tamb\u00e9m \u00e9 poss\u00edvel instalar o Horse de forma manual. Para isso, basta realizar o download do Horse clicando aqui . Se voc\u00ea estiver utilizando o Delphi, o pr\u00f3ximo passo \u00e9 adicionar no Library Path da sua IDE ou em Project > Options > Resource Compiler > Directories and Conditionals > Include file search path do seu projeto, o diret\u00f3rio horse/src . No Lazarus voc\u00ea pode adicionar o diret\u00f3rio horse/src em Project > Project Options > Compiler Options > Path > Other unit files do seu projeto.","title":"Instala\u00e7\u00e3o manual"},{"location":"missing-translations/","text":"es Espa\u00f1ol fr Fran\u00e7ais de Deutsche it Italiano ja Japanese !!! warning The current page still doesn't have a translation for those languages. But you can help translating it: [Contributing](https://github.com/HashLoad/horse-doc){.internal-link target=_blank}. Recommended Languages Tree /mkdocs.yml theme: languages: - en: /en/ # - az: /az/ # - de: /de/ # - es: /es/ # - fa: /fa/ # - fr: /fr/ # - id: /id/ # - it: /it/ # - ja: /ja/ # - ko: /ko/ # - nl: /nl/ # - pl: /pl/ - pt: /pt/ # - ru: /ru/ # - sq: /sq/ # - tr: /tr/ # - uk: /uk/ # - zh: /zh/ Recommended Languages Extra configuration ` /mkdocs.yml extra: alternate: - link: /en/ name: en - English # - link: /az/ # name: az # - link: /de/ # name: de # - link: /es/ # name: es - espa\u00f1ol # - link: /fa/ # name: fa # - link: /fr/ # name: fr - fran\u00e7ais # - link: /id/ # name: id # - link: /it/ # name: it - italiano # - link: /ja/ # name: ja - \u65e5\u672c\u8a9e # - link: /ko/ # name: ko - \ud55c\uad6d\uc5b4 # - link: /nl/ # name: nl # - link: /pl/ # name: pl - link: /pt/ name: pt - portugu\u00eas # - link: /ru/ # name: ru - \u0440\u0443\u0441\u0441\u043a\u0438\u0439 \u044f\u0437\u044b\u043a # - link: /sq/ # name: sq - shqip # - link: /tr/ # name: tr - T\u00fcrk\u00e7e # - link: /uk/ # name: uk - \u0443\u043a\u0440\u0430\u0457\u043d\u0441\u044c\u043a\u0430 \u043c\u043e\u0432\u0430 # - link: /zh/ # name: zh - \u6c49\u8bed","title":"Missing translations"},{"location":"routing/","text":"Roteamento O Roteamento \u00e9 o mecanismo pelo qual as requisi\u00e7\u00f5es s\u00e3o direcionadas para o c\u00f3digo que as trata. Para obter uma introdu\u00e7\u00e3o a roteamento, consulte Roteamento b\u00e1sico . O c\u00f3digo a seguir \u00e9 um exemplo de uma rota muito b\u00e1sica. uses Horse ; begin THorse . Get ( '/ping' , procedure ( Req : THorseRequest ; Res : THorseResponse ; Next : TProc ) begin Res . Send ( 'pong' ) ; end ) ; THorse . Listen ( 9000 ) ; end . M\u00e9todos de roteamento Um m\u00e9todo de roteamento \u00e9 derivado a partir de um dos m\u00e9todos HTTP , e \u00e9 anexado a uma procedure que ir\u00e1 tratar esta requisi\u00e7\u00e3o. o c\u00f3digo a seguir \u00e9 um exemplo de rotas para a raiz do aplicativo que est\u00e3o definidas para os m\u00e9todos GET e POST. uses Horse ; begin THorse . Get ( '/' , procedure ( Req : THorseRequest ; Res : THorseResponse ; Next : TProc ) begin Res . Send ( 'GET request to the root' ) ; end ) ; THorse . Post ( '/' , procedure ( Req : THorseRequest ; Res : THorseResponse ; Next : TProc ) begin Res . Send ( 'POST request to the root' ) ; end ) THorse . Listen ( 9000 ) ; end . O Horse suporta os seguintes m\u00e9todos de roteamento que correspondem aos m\u00e9todos HTTP : GET, POST, PUT, PATCH, HEAD, DELETE. Existe um m\u00e9todo de roteamento especial, THorse.All, que n\u00e3o \u00e9 derivado de nenhum m\u00e9todo HTTP . Este m\u00e9todo \u00e9 usado para carregar procedures em um caminho para todos os m\u00e9todos de solicita\u00e7\u00e3o. No exemplo a seguir, o manipulador ir\u00e1 ser executado para solicita\u00e7\u00f5es para \u201c/test\u201d se voc\u00ea estiver usando GET, POST, PUT, DELETE, ou qualquer outro m\u00e9todo de solicita\u00e7\u00e3o HTTP que \u00e9 suportado pelo Horse. THorse . All ( '/test' , procedure ( Req : THorseRequest ; Res : THorseResponse ; Next : TProc ) begin Res . Send ( 'Test Response' ) ; end ) ; M\u00e9todos de resposta Os m\u00e9todos do objeto de resposta (res) na seguinte tabela podem enviar uma resposta ao cliente, e finalizar o ciclo solicita\u00e7\u00e3o-resposta. M\u00e9todo Descri\u00e7\u00e3o Res.Download(AFileName) Solicita que seja efetuado o download de um arquivo Res.RedirectTo(ALocation) Redireciona uma solicita\u00e7\u00e3o Res.SendFile(AFileName) Envia um arquivo Res.Send(AContent) Envia uma string Res.Send<T: class> Envia um objeto Res.Status(AStatus) Configura o c\u00f3digo do status de resposta Res.ContentType(AContentType) Configura o ContentType da resposta","title":"Roteamento"},{"location":"routing/#roteamento","text":"O Roteamento \u00e9 o mecanismo pelo qual as requisi\u00e7\u00f5es s\u00e3o direcionadas para o c\u00f3digo que as trata. Para obter uma introdu\u00e7\u00e3o a roteamento, consulte Roteamento b\u00e1sico . O c\u00f3digo a seguir \u00e9 um exemplo de uma rota muito b\u00e1sica. uses Horse ; begin THorse . Get ( '/ping' , procedure ( Req : THorseRequest ; Res : THorseResponse ; Next : TProc ) begin Res . Send ( 'pong' ) ; end ) ; THorse . Listen ( 9000 ) ; end .","title":"Roteamento"},{"location":"routing/#metodos-de-roteamento","text":"Um m\u00e9todo de roteamento \u00e9 derivado a partir de um dos m\u00e9todos HTTP , e \u00e9 anexado a uma procedure que ir\u00e1 tratar esta requisi\u00e7\u00e3o. o c\u00f3digo a seguir \u00e9 um exemplo de rotas para a raiz do aplicativo que est\u00e3o definidas para os m\u00e9todos GET e POST. uses Horse ; begin THorse . Get ( '/' , procedure ( Req : THorseRequest ; Res : THorseResponse ; Next : TProc ) begin Res . Send ( 'GET request to the root' ) ; end ) ; THorse . Post ( '/' , procedure ( Req : THorseRequest ; Res : THorseResponse ; Next : TProc ) begin Res . Send ( 'POST request to the root' ) ; end ) THorse . Listen ( 9000 ) ; end . O Horse suporta os seguintes m\u00e9todos de roteamento que correspondem aos m\u00e9todos HTTP : GET, POST, PUT, PATCH, HEAD, DELETE. Existe um m\u00e9todo de roteamento especial, THorse.All, que n\u00e3o \u00e9 derivado de nenhum m\u00e9todo HTTP . Este m\u00e9todo \u00e9 usado para carregar procedures em um caminho para todos os m\u00e9todos de solicita\u00e7\u00e3o. No exemplo a seguir, o manipulador ir\u00e1 ser executado para solicita\u00e7\u00f5es para \u201c/test\u201d se voc\u00ea estiver usando GET, POST, PUT, DELETE, ou qualquer outro m\u00e9todo de solicita\u00e7\u00e3o HTTP que \u00e9 suportado pelo Horse. THorse . All ( '/test' , procedure ( Req : THorseRequest ; Res : THorseResponse ; Next : TProc ) begin Res . Send ( 'Test Response' ) ; end ) ;","title":"M\u00e9todos de roteamento"},{"location":"routing/#metodos-de-resposta","text":"Os m\u00e9todos do objeto de resposta (res) na seguinte tabela podem enviar uma resposta ao cliente, e finalizar o ciclo solicita\u00e7\u00e3o-resposta. M\u00e9todo Descri\u00e7\u00e3o Res.Download(AFileName) Solicita que seja efetuado o download de um arquivo Res.RedirectTo(ALocation) Redireciona uma solicita\u00e7\u00e3o Res.SendFile(AFileName) Envia um arquivo Res.Send(AContent) Envia uma string Res.Send<T: class> Envia um objeto Res.Status(AStatus) Configura o c\u00f3digo do status de resposta Res.ContentType(AContentType) Configura o ContentType da resposta","title":"M\u00e9todos de resposta"},{"location":"en/","text":"Horse What is Horse? Horse is a framework for building web applications in Delphi and Lazarus. As the main library, it is easy to adopt and integrate with other existing libraries or projects. First Steps The simplest way to test Horse is by installing. Feel free to install it and accompany us with some basic examples. In the topic Installation you will see how to install Horse. Basic Notions At the heart of Horse is a system that allows us to declaratively map HTTP routes using a very simple syntax: uses Horse ; begin THorse . Get ( '/ping' , procedure ( Req : THorseRequest ; Res : THorseResponse ; Next : TProc ) begin Res . Send ( 'pong' ) ; end ) ; THorse . Listen ( 9000 ) ; end . We just created our first Horse server! Ready for More? We introduced Horse briefly - the rest of this guide will delve into other advanced features in a much greater level of detail, so read on! See more at: * Installing Horse. * Creating a Hello world! . * Understanding routing . [URI]: Uniform Resource Identifier [HTTP]: Hypertext Transfer Protocol","title":"Welcome"},{"location":"en/#horse","text":"","title":"Horse"},{"location":"en/#what-is-horse","text":"Horse is a framework for building web applications in Delphi and Lazarus. As the main library, it is easy to adopt and integrate with other existing libraries or projects.","title":"What is Horse?"},{"location":"en/#first-steps","text":"The simplest way to test Horse is by installing. Feel free to install it and accompany us with some basic examples. In the topic Installation you will see how to install Horse.","title":"First Steps"},{"location":"en/#basic-notions","text":"At the heart of Horse is a system that allows us to declaratively map HTTP routes using a very simple syntax: uses Horse ; begin THorse . Get ( '/ping' , procedure ( Req : THorseRequest ; Res : THorseResponse ; Next : TProc ) begin Res . Send ( 'pong' ) ; end ) ; THorse . Listen ( 9000 ) ; end . We just created our first Horse server!","title":"Basic Notions"},{"location":"en/#ready-for-more","text":"We introduced Horse briefly - the rest of this guide will delve into other advanced features in a much greater level of detail, so read on! See more at: * Installing Horse. * Creating a Hello world! . * Understanding routing . [URI]: Uniform Resource Identifier [HTTP]: Hypertext Transfer Protocol","title":"Ready for More?"},{"location":"en/%23%20Diagramas/","text":"Diagramas graph TD; A-->B; A-->C; B-->D; C-->D; graph LR A[Square Rect] -- Link text --> B((Circle)) A --> C(Round Rect) B --> D{Rhombus} C --> D stateDiagram-v2 [ ] --> Still Still --> [ ] Still --> Moving Moving --> Still Moving --> Crash Crash --> [*] States A state can be declared in multiple ways. The simplest way is to define a state id as a description. stateDiagram-v2 s1 s1 Another way is by using the state keyword with a description as per below: stateDiagram-v2 state \"This is a state description\" as s2 This is a state description Another way to define a state with a description is to define the state id followed by a colon and the description: stateDiagram-v2 s2 : This is a state description This is a state description Transitions Transitions are path/edges when one state passes into another. This is represented using text arrow, \"-->\". When you define a transition between two states and the states are not already defined the undefined states are defined with the id from the transition. You can later add descriptions to states defined this way. stateDiagram-v2 s1 --> s2 s1 v s2 It is possible to add text to a transition. To describe what it represents. stateDiagram-v2 s1 --> s2: A transition s1 | A transition v s2 Start and End There are two special states indicating the start and stop of the diagram. These are written with the [*] syntax and the direction of the transition to it defines it either as a start or a stop state. stateDiagram-v2 [*] --> s1 s1 --> [*] (o)-->s1-->(o)","title":"Diagramas"},{"location":"en/%23%20Diagramas/#diagramas","text":"graph TD; A-->B; A-->C; B-->D; C-->D; graph LR A[Square Rect] -- Link text --> B((Circle)) A --> C(Round Rect) B --> D{Rhombus} C --> D stateDiagram-v2 [ ] --> Still Still --> [ ] Still --> Moving Moving --> Still Moving --> Crash Crash --> [*] States A state can be declared in multiple ways. The simplest way is to define a state id as a description. stateDiagram-v2 s1 s1 Another way is by using the state keyword with a description as per below: stateDiagram-v2 state \"This is a state description\" as s2 This is a state description Another way to define a state with a description is to define the state id followed by a colon and the description: stateDiagram-v2 s2 : This is a state description This is a state description Transitions Transitions are path/edges when one state passes into another. This is represented using text arrow, \"-->\". When you define a transition between two states and the states are not already defined the undefined states are defined with the id from the transition. You can later add descriptions to states defined this way. stateDiagram-v2 s1 --> s2 s1 v s2 It is possible to add text to a transition. To describe what it represents. stateDiagram-v2 s1 --> s2: A transition s1 | A transition v s2 Start and End There are two special states indicating the start and stop of the diagram. These are written with the [*] syntax and the direction of the transition to it defines it either as a start or a stop state. stateDiagram-v2 [*] --> s1 s1 --> [*] (o)-->s1-->(o)","title":"Diagramas"},{"location":"en/basic-routing/","text":"Routing determines how the application will respond to a request from a client at an endpoint , which would be the URI and a specific method of the HTTP protocol (POST, PUT, GET, DELETE and so on). On the route, it is possible to have more than one treatment, which will be executed when the route that was requested is the corresponding one. The route has the following structure: THorse . METHOD ( PATH , HANDLER ) ; Where: METHOD is an HTTP request method. PATH it's a path on the server. HANDLER is the method (procedure) that will be executed when the route is matched. The following examples illustrate the definition of simple routes. Reply with \"Hello World!\" to whoever requested ( client who made the request ): GET POST PUT DELETE THorse . Get ( '/ping' , procedure ( Req : THorseRequest ; Res : THorseResponse ; Next : TProc ) begin Res . Send ( 'Hello World!' ) ; end ) ; Respond to POST request on the root route (/): THorse . Post ( '/' , procedure ( Req : THorseRequest ; Res : THorseResponse ; Next : TProc ) begin Res . Send ( 'Got a POST request' ) ; end ) ; Respond to a PUT request to the /user route THorse . Put ( '/user' , procedure ( Req : THorseRequest ; Res : THorseResponse ; Next : TProc ) begin Res . Send ( 'Got a PUT request at /user' ) ; end ) ; Respond to a DELETE request to the /user route THorse . Delete ( '/user' , procedure ( Req : THorseRequest ; Res : THorseResponse ; Next : TProc ) begin Res . Send ( 'Got a DELETE request at /user' ) ; end ) ;","title":"Routing"},{"location":"en/hello-world/","text":"Hello world! First create a console project in Delphi or Lazarus, save the project with the name you want (in this example, it will be saved as hashload_horse ). Then install Horse as a dependency on your project, according to the installation guide . After Horse is created and installed in your project, include the following code: Delphi Lazarus uses System . SysUtils , Horse ; const HORSE_PORT = 9000 ; begin THorse . Get ( '/' , procedure ( Req : THorseRequest ; Res : THorseResponse ; Next : TProc ) begin Res . Send ( 'Hello Word!' ) ; end ) ; THorse . Listen ( HORSE_PORT , procedure ( Horse : THorse ) begin Writeln ( Format ( 'Server is running on %s:%d' , [ Horse . Host , Horse . Port ])) ; end ) end . {$MODE DELPHI}{$H+} uses SysUtils , Horse ; const HORSE_PORT = 9000 ; procedure GetHelloWorld ( Req : THorseRequest ; Res : THorseResponse ; Next : TNextProc ) ; begin Res . Send ( 'Hello Word!' ) ; end ; procedure HorseListenCallback ( Horse : THorse ) ; begin Writeln ( Format ( 'Server is running on %s:%d' , [ Horse . Host , Horse . Port ])) ; end ; begin THorse . Get ( '/' , GetHelloWorld ) ; THorse . Listen ( HORSE_PORT , HorseListenCallback ) ; end . The application starts a server and listens for connections on port 9000. The application responds with a Hello, world! on the route (/) to the client that made the request . For all other paths, it will respond with a Not Found message and status code 404 Now, compile and run the application. You will have as a result on the console something like Server is running on 0.0.0.0:9000 Then open a browser, type http://localhost:9000/ in the address bar and browse to view the output. If you were able to view the result in your browser, this is great, your server worked correctly. Now you're ready to evolve on Horse! See more at: Understanding routing","title":"Hello world!"},{"location":"en/hello-world/#hello-world","text":"First create a console project in Delphi or Lazarus, save the project with the name you want (in this example, it will be saved as hashload_horse ). Then install Horse as a dependency on your project, according to the installation guide . After Horse is created and installed in your project, include the following code: Delphi Lazarus uses System . SysUtils , Horse ; const HORSE_PORT = 9000 ; begin THorse . Get ( '/' , procedure ( Req : THorseRequest ; Res : THorseResponse ; Next : TProc ) begin Res . Send ( 'Hello Word!' ) ; end ) ; THorse . Listen ( HORSE_PORT , procedure ( Horse : THorse ) begin Writeln ( Format ( 'Server is running on %s:%d' , [ Horse . Host , Horse . Port ])) ; end ) end . {$MODE DELPHI}{$H+} uses SysUtils , Horse ; const HORSE_PORT = 9000 ; procedure GetHelloWorld ( Req : THorseRequest ; Res : THorseResponse ; Next : TNextProc ) ; begin Res . Send ( 'Hello Word!' ) ; end ; procedure HorseListenCallback ( Horse : THorse ) ; begin Writeln ( Format ( 'Server is running on %s:%d' , [ Horse . Host , Horse . Port ])) ; end ; begin THorse . Get ( '/' , GetHelloWorld ) ; THorse . Listen ( HORSE_PORT , HorseListenCallback ) ; end . The application starts a server and listens for connections on port 9000. The application responds with a Hello, world! on the route (/) to the client that made the request . For all other paths, it will respond with a Not Found message and status code 404 Now, compile and run the application. You will have as a result on the console something like Server is running on 0.0.0.0:9000 Then open a browser, type http://localhost:9000/ in the address bar and browse to view the output. If you were able to view the result in your browser, this is great, your server worked correctly. Now you're ready to evolve on Horse! See more at: Understanding routing","title":"Hello world!"},{"location":"en/installation/","text":"Boss The easiest and recommended way to install Horse is with Boss . With it you can manage the version of the dependencies used in your API, in addition to automatically configuring your project's * Library Path *. To perform the installation, simply open the terminal of your choice and enter the following commands: $ boss init $ boss install horse NOTE: it is worth mentioning that the command boss init is to initialize the dependency manager and must be executed only once. If you have already done so, there is no need to do it again. Manual Download the latest version of Horse and include the src/ folder in your project's Library Path . See more at: * Creating a Hello world! .","title":"Installation"},{"location":"en/installation/#boss","text":"The easiest and recommended way to install Horse is with Boss . With it you can manage the version of the dependencies used in your API, in addition to automatically configuring your project's * Library Path *. To perform the installation, simply open the terminal of your choice and enter the following commands: $ boss init $ boss install horse NOTE: it is worth mentioning that the command boss init is to initialize the dependency manager and must be executed only once. If you have already done so, there is no need to do it again.","title":"Boss"},{"location":"en/installation/#manual","text":"Download the latest version of Horse and include the src/ folder in your project's Library Path . See more at: * Creating a Hello world! .","title":"Manual"},{"location":"en/missing-translations/","text":"es Espa\u00f1ol fr Fran\u00e7ais de Deutsche it Italiano ja Japanese !!! warning The current page still doesn't have a translation for those languages. But you can help translating it: [Contributing](https://github.com/HashLoad/horse-doc){.internal-link target=_blank}. Recommended Languages Tree /mkdocs.yml theme: languages: - en: /en/ # - az: /az/ # - de: /de/ # - es: /es/ # - fa: /fa/ # - fr: /fr/ # - id: /id/ # - it: /it/ # - ja: /ja/ # - ko: /ko/ # - nl: /nl/ # - pl: /pl/ - pt: /pt/ # - ru: /ru/ # - sq: /sq/ # - tr: /tr/ # - uk: /uk/ # - zh: /zh/ Recommended Languages Extra configuration ` /mkdocs.yml extra: alternate: - link: /en/ name: en - English # - link: /az/ # name: az # - link: /de/ # name: de # - link: /es/ # name: es - espa\u00f1ol # - link: /fa/ # name: fa # - link: /fr/ # name: fr - fran\u00e7ais # - link: /id/ # name: id # - link: /it/ # name: it - italiano # - link: /ja/ # name: ja - \u65e5\u672c\u8a9e # - link: /ko/ # name: ko - \ud55c\uad6d\uc5b4 # - link: /nl/ # name: nl # - link: /pl/ # name: pl - link: /pt/ name: pt - portugu\u00eas # - link: /ru/ # name: ru - \u0440\u0443\u0441\u0441\u043a\u0438\u0439 \u044f\u0437\u044b\u043a # - link: /sq/ # name: sq - shqip # - link: /tr/ # name: tr - T\u00fcrk\u00e7e # - link: /uk/ # name: uk - \u0443\u043a\u0440\u0430\u0457\u043d\u0441\u044c\u043a\u0430 \u043c\u043e\u0432\u0430 # - link: /zh/ # name: zh - \u6c49\u8bed","title":"Missing translations"},{"location":"en/routing/","text":"Roteamento O Roteamento \u00e9 o mecanismo pelo qual as requisi\u00e7\u00f5es s\u00e3o direcionadas para o c\u00f3digo que as trata. Para obter uma introdu\u00e7\u00e3o a roteamento, consulte Roteamento b\u00e1sico . O c\u00f3digo a seguir \u00e9 um exemplo de uma rota muito b\u00e1sica. uses Horse ; begin THorse . Get ( '/ping' , procedure ( Req : THorseRequest ; Res : THorseResponse ; Next : TProc ) begin Res . Send ( 'pong' ) ; end ) ; THorse . Listen ( 9000 ) ; end . M\u00e9todos de roteamento Um m\u00e9todo de roteamento \u00e9 derivado a partir de um dos m\u00e9todos HTTP , e \u00e9 anexado a uma procedure que ir\u00e1 tratar esta requisi\u00e7\u00e3o. o c\u00f3digo a seguir \u00e9 um exemplo de rotas para a raiz do aplicativo que est\u00e3o definidas para os m\u00e9todos GET e POST. uses Horse ; begin THorse . Get ( '/' , procedure ( Req : THorseRequest ; Res : THorseResponse ; Next : TProc ) begin Res . Send ( 'GET request to the root' ) ; end ) ; THorse . Post ( '/' , procedure ( Req : THorseRequest ; Res : THorseResponse ; Next : TProc ) begin Res . Send ( 'POST request to the root' ) ; end ) THorse . Listen ( 9000 ) ; end . O Horse suporta os seguintes m\u00e9todos de roteamento que correspondem aos m\u00e9todos HTTP : GET, POST, PUT, PATCH, HEAD, DELETE. Existe um m\u00e9todo de roteamento especial, THorse.All, que n\u00e3o \u00e9 derivado de nenhum m\u00e9todo HTTP . Este m\u00e9todo \u00e9 usado para carregar procedures em um caminho para todos os m\u00e9todos de solicita\u00e7\u00e3o. No exemplo a seguir, o manipulador ir\u00e1 ser executado para solicita\u00e7\u00f5es para \u201c/test\u201d se voc\u00ea estiver usando GET, POST, PUT, DELETE, ou qualquer outro m\u00e9todo de solicita\u00e7\u00e3o HTTP que \u00e9 suportado pelo Horse. THorse . All ( '/test' , procedure ( Req : THorseRequest ; Res : THorseResponse ; Next : TProc ) begin Res . Send ( 'Test Response' ) ; end ) ; M\u00e9todos de resposta Os m\u00e9todos do objeto de resposta (res) na seguinte tabela podem enviar uma resposta ao cliente, e finalizar o ciclo solicita\u00e7\u00e3o-resposta. M\u00e9todo Descri\u00e7\u00e3o Res.Download(AFileName) Solicita que seja efetuado o download de um arquivo Res.RedirectTo(ALocation) Redireciona uma solicita\u00e7\u00e3o Res.SendFile(AFileName) Envia um arquivo Res.Send(AContent) Envia uma string Res.Send<T: class> Envia um objeto Res.Status(AStatus) Configura o c\u00f3digo do status de resposta Res.ContentType(AContentType) Configura o ContentType da resposta","title":"Roteamento"},{"location":"en/routing/#roteamento","text":"O Roteamento \u00e9 o mecanismo pelo qual as requisi\u00e7\u00f5es s\u00e3o direcionadas para o c\u00f3digo que as trata. Para obter uma introdu\u00e7\u00e3o a roteamento, consulte Roteamento b\u00e1sico . O c\u00f3digo a seguir \u00e9 um exemplo de uma rota muito b\u00e1sica. uses Horse ; begin THorse . Get ( '/ping' , procedure ( Req : THorseRequest ; Res : THorseResponse ; Next : TProc ) begin Res . Send ( 'pong' ) ; end ) ; THorse . Listen ( 9000 ) ; end .","title":"Roteamento"},{"location":"en/routing/#metodos-de-roteamento","text":"Um m\u00e9todo de roteamento \u00e9 derivado a partir de um dos m\u00e9todos HTTP , e \u00e9 anexado a uma procedure que ir\u00e1 tratar esta requisi\u00e7\u00e3o. o c\u00f3digo a seguir \u00e9 um exemplo de rotas para a raiz do aplicativo que est\u00e3o definidas para os m\u00e9todos GET e POST. uses Horse ; begin THorse . Get ( '/' , procedure ( Req : THorseRequest ; Res : THorseResponse ; Next : TProc ) begin Res . Send ( 'GET request to the root' ) ; end ) ; THorse . Post ( '/' , procedure ( Req : THorseRequest ; Res : THorseResponse ; Next : TProc ) begin Res . Send ( 'POST request to the root' ) ; end ) THorse . Listen ( 9000 ) ; end . O Horse suporta os seguintes m\u00e9todos de roteamento que correspondem aos m\u00e9todos HTTP : GET, POST, PUT, PATCH, HEAD, DELETE. Existe um m\u00e9todo de roteamento especial, THorse.All, que n\u00e3o \u00e9 derivado de nenhum m\u00e9todo HTTP . Este m\u00e9todo \u00e9 usado para carregar procedures em um caminho para todos os m\u00e9todos de solicita\u00e7\u00e3o. No exemplo a seguir, o manipulador ir\u00e1 ser executado para solicita\u00e7\u00f5es para \u201c/test\u201d se voc\u00ea estiver usando GET, POST, PUT, DELETE, ou qualquer outro m\u00e9todo de solicita\u00e7\u00e3o HTTP que \u00e9 suportado pelo Horse. THorse . All ( '/test' , procedure ( Req : THorseRequest ; Res : THorseResponse ; Next : TProc ) begin Res . Send ( 'Test Response' ) ; end ) ;","title":"M\u00e9todos de roteamento"},{"location":"en/routing/#metodos-de-resposta","text":"Os m\u00e9todos do objeto de resposta (res) na seguinte tabela podem enviar uma resposta ao cliente, e finalizar o ciclo solicita\u00e7\u00e3o-resposta. M\u00e9todo Descri\u00e7\u00e3o Res.Download(AFileName) Solicita que seja efetuado o download de um arquivo Res.RedirectTo(ALocation) Redireciona uma solicita\u00e7\u00e3o Res.SendFile(AFileName) Envia um arquivo Res.Send(AContent) Envia uma string Res.Send<T: class> Envia um objeto Res.Status(AStatus) Configura o c\u00f3digo do status de resposta Res.ContentType(AContentType) Configura o ContentType da resposta","title":"M\u00e9todos de resposta"}]}