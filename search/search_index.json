{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Horse O que \u00e9 o Horse? Horse \u00e9 um framework para aplica\u00e7\u00f5es web compat\u00edvel com Delphi e Lazarus. F\u00e1cil de ser adotada e integrada com outras bibliotecas ou projetos. Primeiros passos A melhor maneira de obter o Horse \u00e9 acessando a nossa P\u00e1gina de instala\u00e7\u00e3o . No\u00e7\u00f5es b\u00e1sicas O cora\u00e7\u00e3o do Horse \u00e9 um sistema que nos permite maper rotas HTTP de forma declarativa, com uma sintaxe muito simples. uses Horse ; begin THorse . Get ( '/ping' , procedure ( Req : THorseRequest ; Res : THorseResponse ; Next : TProc ) begin Res . Send ( 'pong' ) ; end ) ; THorse . Listen ( 9000 ) ; end . E n\u00f3s j\u00e1 criamos nosso primeiro servidor! Pronto para mais? Esta \u00e9 apenas uma breve introdu\u00e7\u00e3o do Horse. Continue o guia para se aprofundar em um maior n\u00famero de detalhes. Ent\u00e3o vamos l\u00e1! Veja mais: * Instalando Horse. * Implementando um Ol\u00e1 mundo! . * Entendendo rotas .","title":"Bem vindo"},{"location":"#horse","text":"","title":"Horse"},{"location":"#o-que-e-o-horse","text":"Horse \u00e9 um framework para aplica\u00e7\u00f5es web compat\u00edvel com Delphi e Lazarus. F\u00e1cil de ser adotada e integrada com outras bibliotecas ou projetos.","title":"O que \u00e9 o Horse?"},{"location":"#primeiros-passos","text":"A melhor maneira de obter o Horse \u00e9 acessando a nossa P\u00e1gina de instala\u00e7\u00e3o .","title":"Primeiros passos"},{"location":"#nocoes-basicas","text":"O cora\u00e7\u00e3o do Horse \u00e9 um sistema que nos permite maper rotas HTTP de forma declarativa, com uma sintaxe muito simples. uses Horse ; begin THorse . Get ( '/ping' , procedure ( Req : THorseRequest ; Res : THorseResponse ; Next : TProc ) begin Res . Send ( 'pong' ) ; end ) ; THorse . Listen ( 9000 ) ; end . E n\u00f3s j\u00e1 criamos nosso primeiro servidor!","title":"No\u00e7\u00f5es b\u00e1sicas"},{"location":"#pronto-para-mais","text":"Esta \u00e9 apenas uma breve introdu\u00e7\u00e3o do Horse. Continue o guia para se aprofundar em um maior n\u00famero de detalhes. Ent\u00e3o vamos l\u00e1! Veja mais: * Instalando Horse. * Implementando um Ol\u00e1 mundo! . * Entendendo rotas .","title":"Pronto para mais?"},{"location":"%23%20Diagramas/","text":"Diagramas graph TD; A-->B; A-->C; B-->D; C-->D; graph LR A[Square Rect] -- Link text --> B((Circle)) A --> C(Round Rect) B --> D{Rhombus} C --> D stateDiagram-v2 [ ] --> Still Still --> [ ] Still --> Moving Moving --> Still Moving --> Crash Crash --> [*] States A state can be declared in multiple ways. The simplest way is to define a state id as a description. stateDiagram-v2 s1 s1 Another way is by using the state keyword with a description as per below: stateDiagram-v2 state \"This is a state description\" as s2 This is a state description Another way to define a state with a description is to define the state id followed by a colon and the description: stateDiagram-v2 s2 : This is a state description This is a state description Transitions Transitions are path/edges when one state passes into another. This is represented using text arrow, \"-->\". When you define a transition between two states and the states are not already defined the undefined states are defined with the id from the transition. You can later add descriptions to states defined this way. stateDiagram-v2 s1 --> s2 s1 v s2 It is possible to add text to a transition. To describe what it represents. stateDiagram-v2 s1 --> s2: A transition s1 | A transition v s2 Start and End There are two special states indicating the start and stop of the diagram. These are written with the [*] syntax and the direction of the transition to it defines it either as a start or a stop state. stateDiagram-v2 [*] --> s1 s1 --> [*] (o)-->s1-->(o)","title":"Diagramas"},{"location":"%23%20Diagramas/#diagramas","text":"graph TD; A-->B; A-->C; B-->D; C-->D; graph LR A[Square Rect] -- Link text --> B((Circle)) A --> C(Round Rect) B --> D{Rhombus} C --> D stateDiagram-v2 [ ] --> Still Still --> [ ] Still --> Moving Moving --> Still Moving --> Crash Crash --> [*] States A state can be declared in multiple ways. The simplest way is to define a state id as a description. stateDiagram-v2 s1 s1 Another way is by using the state keyword with a description as per below: stateDiagram-v2 state \"This is a state description\" as s2 This is a state description Another way to define a state with a description is to define the state id followed by a colon and the description: stateDiagram-v2 s2 : This is a state description This is a state description Transitions Transitions are path/edges when one state passes into another. This is represented using text arrow, \"-->\". When you define a transition between two states and the states are not already defined the undefined states are defined with the id from the transition. You can later add descriptions to states defined this way. stateDiagram-v2 s1 --> s2 s1 v s2 It is possible to add text to a transition. To describe what it represents. stateDiagram-v2 s1 --> s2: A transition s1 | A transition v s2 Start and End There are two special states indicating the start and stop of the diagram. These are written with the [*] syntax and the direction of the transition to it defines it either as a start or a stop state. stateDiagram-v2 [*] --> s1 s1 --> [*] (o)-->s1-->(o)","title":"Diagramas"},{"location":"basic-routing/","text":"Rotas determinam como a aplica\u00e7\u00e3o responder\u00e1 a uma requisi\u00e7\u00e3o do cliente em um caminho espec\u00edfico chamado endpoint , que \u00e9 uma URI que especifica um m\u00e9todo do protocolo HTTP (POST, PUT, GET, DELETE e al\u00e9m). Cada rota pode ter mais de um tratamento, que responder\u00e1 de acordo com a requisi\u00e7\u00e3o correspondente. Uma rota possui a seguinte estrutura THorse . METHOD ( PATH , HANDLER ) ; Onde: METHOD \u00e9 um m\u00e9todo HTTP. PATH \u00e9 o caminho no servidor. HANDLER \u00e9 um m\u00e9todo do delphi (procedure) quando esta rota for acessada. Os exemplos a seguir ilustram a defini\u00e7\u00e3o de rotas simples Reply with \"Hello World!\" to whoever requested ( client who made the request ): THorse . Get ( '/ping' , procedure ( Req : THorseRequest ; Res : THorseResponse ; Next : TProc ) begin Res . Send ( 'Hello World!' ) ; end ) ; Respond to POST request on the root route (/): THorse . Post ( '/' , procedure ( Req : THorseRequest ; Res : THorseResponse ; Next : TProc ) begin Res . Send ( 'Got a POST request' ) ; end ) ; Respond to a PUT request to the /user route: THorse . Put ( '/user' , procedure ( Req : THorseRequest ; Res : THorseResponse ; Next : TProc ) begin Res . Send ( 'Got a PUT request at /user' ) ; end ) ; Respond to a DELETE request to the /user route: THorse . Delete ( '/user' , procedure ( Req : THorseRequest ; Res : THorseResponse ; Next : TProc ) begin Res . Send ( 'Got a DELETE request at /user' ) ; end ) ; NOTA: A vers\u00e3o atual do Lazarus 3.2.2 n\u00e3o tem suporte a m\u00e9todos an\u00f4nimos, veja o exemplo em Ol\u00e1 Mundo de como informar o callback no Lazarus","title":"Rotas"},{"location":"hello-world/","text":"Ol\u00e1 mundo! Crie um projeto do tipo Console Application com o Delphi ou Lazarus, salve o seu projeto com o nome que voc\u00ea quiser (este exemplo foi salvo com o nome hashload_horse ). Ent\u00e3o instale o Horse e inclua nas depend\u00eancias do seu projeto, de acordo com o guia de instala\u00e7\u00e3o . Ap\u00f3s instalar o Horse e criar o seu projeto, inclua o seguinte c\u00f3digo: Delphi uses System . SysUtils , Horse ; const HORSE_PORT = 9000 ; begin THorse . Get ( '/' , procedure ( Req : THorseRequest ; Res : THorseResponse ; Next : TProc ) begin Res . Send ( 'Ol\u00e1, mundo!' ) ; end ) ; THorse . Listen ( HORSE_PORT , procedure ( Horse : THorse ) begin Writeln ( Format ( 'O servidor est\u00e1 rodando em %s:%d' , [ Horse . Host , Horse . Port ])) ; end ) end . Lazarus {$MODE DELPHI}{$H+} uses SysUtils , Horse ; const HORSE_PORT = 9000 ; procedure GetHelloWorld ( Req : THorseRequest ; Res : THorseResponse ; Next : TNextProc ) ; begin Res . Send ( 'Ola Mundo!' ) ; end ; procedure HorseListenCallback ( Horse : THorse ) ; begin Writeln ( Format ( 'O servidor esta rodando em %s:%d' , [ Horse . Host , Horse . Port ])) ; end ; begin THorse . Get ( '/' , GetHelloWorld ) ; THorse . Listen ( HORSE_PORT , HorseListenCallback ) ; end . A aplica\u00e7\u00e3o ir\u00e1 iniciar um servidor escutando na porta 9000. Agora, compile e rode a aplica\u00e7\u00e3o. Voc\u00ea ver\u00e1 no console a mensagem Servidor rodando em 0.0.0.0:9000 A Aplica\u00e7\u00e3o ir\u00e1 responder com a mensagem \"Ol\u00e1 Mundo\" na rota (/) para o cliente que fizer a requisi\u00e7\u00e3o . Para qualquer outra rota, ela ir\u00e1 responder com uma mensagem Not Found e status code 404 (N\u00e3o encontrado) Ent\u00e3o abra o browser, digite http://localhost:9000/ para acessar a sua primeira rota. Agora Voc\u00ea est\u00e1 pronto para desenvolver com o Horse! Pr\u00f3ximo passo: * Entendendo rotas .","title":"Ol\u00e1 Mundo"},{"location":"hello-world/#ola-mundo","text":"Crie um projeto do tipo Console Application com o Delphi ou Lazarus, salve o seu projeto com o nome que voc\u00ea quiser (este exemplo foi salvo com o nome hashload_horse ). Ent\u00e3o instale o Horse e inclua nas depend\u00eancias do seu projeto, de acordo com o guia de instala\u00e7\u00e3o . Ap\u00f3s instalar o Horse e criar o seu projeto, inclua o seguinte c\u00f3digo:","title":"Ol\u00e1 mundo!"},{"location":"hello-world/#delphi","text":"uses System . SysUtils , Horse ; const HORSE_PORT = 9000 ; begin THorse . Get ( '/' , procedure ( Req : THorseRequest ; Res : THorseResponse ; Next : TProc ) begin Res . Send ( 'Ol\u00e1, mundo!' ) ; end ) ; THorse . Listen ( HORSE_PORT , procedure ( Horse : THorse ) begin Writeln ( Format ( 'O servidor est\u00e1 rodando em %s:%d' , [ Horse . Host , Horse . Port ])) ; end ) end .","title":"Delphi"},{"location":"hello-world/#lazarus","text":"{$MODE DELPHI}{$H+} uses SysUtils , Horse ; const HORSE_PORT = 9000 ; procedure GetHelloWorld ( Req : THorseRequest ; Res : THorseResponse ; Next : TNextProc ) ; begin Res . Send ( 'Ola Mundo!' ) ; end ; procedure HorseListenCallback ( Horse : THorse ) ; begin Writeln ( Format ( 'O servidor esta rodando em %s:%d' , [ Horse . Host , Horse . Port ])) ; end ; begin THorse . Get ( '/' , GetHelloWorld ) ; THorse . Listen ( HORSE_PORT , HorseListenCallback ) ; end . A aplica\u00e7\u00e3o ir\u00e1 iniciar um servidor escutando na porta 9000. Agora, compile e rode a aplica\u00e7\u00e3o. Voc\u00ea ver\u00e1 no console a mensagem Servidor rodando em 0.0.0.0:9000 A Aplica\u00e7\u00e3o ir\u00e1 responder com a mensagem \"Ol\u00e1 Mundo\" na rota (/) para o cliente que fizer a requisi\u00e7\u00e3o . Para qualquer outra rota, ela ir\u00e1 responder com uma mensagem Not Found e status code 404 (N\u00e3o encontrado) Ent\u00e3o abra o browser, digite http://localhost:9000/ para acessar a sua primeira rota. Agora Voc\u00ea est\u00e1 pronto para desenvolver com o Horse! Pr\u00f3ximo passo: * Entendendo rotas .","title":"Lazarus"},{"location":"installation/","text":"Boss A maneira mais f\u00e1cil de instalar o Horse \u00e9 utilizando o Boss (Recomendado) Esta ferramenta poder\u00e1 auxiliar a gerenciar pacotes de depend\u00eancias e vers\u00f5es utilizadas na sua api. Ela tamb\u00e9m ir\u00e1 configurar seu projeto automaticamente na * Library Path *. Para realizar a instala\u00e7\u00e3o, simplesmente abra o terminal de sua escolha e digite o seguinte comando: $ boss init $ boss install horse NOTA: O comando boss init serve para inicializar o gerenciador de depend\u00eancias e deve ser executado apenas uma vez. Se voc\u00ea j\u00e1 fez isso, n\u00e3o h\u00e1 necessidade de faz\u00ea-lo novamente. Manual Baixe a vers\u00e3o mais nova do Horse e inclua o diret\u00f3rio src/ na sua Library Path . Veja mais em: * Implementando um Ol\u00e1 Mundo! .","title":"Instala\u00e7\u00e3o"},{"location":"installation/#boss","text":"A maneira mais f\u00e1cil de instalar o Horse \u00e9 utilizando o Boss (Recomendado) Esta ferramenta poder\u00e1 auxiliar a gerenciar pacotes de depend\u00eancias e vers\u00f5es utilizadas na sua api. Ela tamb\u00e9m ir\u00e1 configurar seu projeto automaticamente na * Library Path *. Para realizar a instala\u00e7\u00e3o, simplesmente abra o terminal de sua escolha e digite o seguinte comando: $ boss init $ boss install horse NOTA: O comando boss init serve para inicializar o gerenciador de depend\u00eancias e deve ser executado apenas uma vez. Se voc\u00ea j\u00e1 fez isso, n\u00e3o h\u00e1 necessidade de faz\u00ea-lo novamente.","title":"Boss"},{"location":"installation/#manual","text":"Baixe a vers\u00e3o mais nova do Horse e inclua o diret\u00f3rio src/ na sua Library Path . Veja mais em: * Implementando um Ol\u00e1 Mundo! .","title":"Manual"},{"location":"missing-translations/","text":"es Espa\u00f1ol fr Fran\u00e7ais de Deutsche it Italiano ja Japanese !!! warning The current page still doesn't have a translation for those languages. But you can help translating it: [Contributing](https://github.com/HashLoad/horse-doc){.internal-link target=_blank}. Recommended Languages Tree /mkdocs.yml theme: languages: - en: /en/ # - az: /az/ # - de: /de/ # - es: /es/ # - fa: /fa/ # - fr: /fr/ # - id: /id/ # - it: /it/ # - ja: /ja/ # - ko: /ko/ # - nl: /nl/ # - pl: /pl/ - pt: /pt/ # - ru: /ru/ # - sq: /sq/ # - tr: /tr/ # - uk: /uk/ # - zh: /zh/ Recommended Languages Extra configuration ` /mkdocs.yml extra: alternate: - link: /en/ name: en - English # - link: /az/ # name: az # - link: /de/ # name: de # - link: /es/ # name: es - espa\u00f1ol # - link: /fa/ # name: fa # - link: /fr/ # name: fr - fran\u00e7ais # - link: /id/ # name: id # - link: /it/ # name: it - italiano # - link: /ja/ # name: ja - \u65e5\u672c\u8a9e # - link: /ko/ # name: ko - \ud55c\uad6d\uc5b4 # - link: /nl/ # name: nl # - link: /pl/ # name: pl - link: /pt/ name: pt - portugu\u00eas # - link: /ru/ # name: ru - \u0440\u0443\u0441\u0441\u043a\u0438\u0439 \u044f\u0437\u044b\u043a # - link: /sq/ # name: sq - shqip # - link: /tr/ # name: tr - T\u00fcrk\u00e7e # - link: /uk/ # name: uk - \u0443\u043a\u0440\u0430\u0457\u043d\u0441\u044c\u043a\u0430 \u043c\u043e\u0432\u0430 # - link: /zh/ # name: zh - \u6c49\u8bed","title":"Missing translations"},{"location":"routing/","text":"Roteamento O Roteamento \u00e9 o mecanismo pelo qual as requisi\u00e7\u00f5es s\u00e3o direcionadas para o c\u00f3digo que as trata. Para obter uma introdu\u00e7\u00e3o a roteamento, consulte Roteamento b\u00e1sico . O c\u00f3digo a seguir \u00e9 um exemplo de uma rota muito b\u00e1sica. uses Horse ; begin THorse . Get ( '/ping' , procedure ( Req : THorseRequest ; Res : THorseResponse ; Next : TProc ) begin Res . Send ( 'pong' ) ; end ) ; THorse . Listen ( 9000 ) ; end . M\u00e9todos de roteamento Um m\u00e9todo de roteamento \u00e9 derivado a partir de um dos m\u00e9todos HTTP, e \u00e9 anexado a uma procedure que ir\u00e1 tratar esta requisi\u00e7\u00e3o. o c\u00f3digo a seguir \u00e9 um exemplo de rotas para a raiz do aplicativo que est\u00e3o definidas para os m\u00e9todos GET e POST. uses Horse ; begin THorse . Get ( '/' , procedure ( Req : THorseRequest ; Res : THorseResponse ; Next : TProc ) begin Res . Send ( 'GET request to the root' ) ; end ) ; THorse . Post ( '/' , procedure ( Req : THorseRequest ; Res : THorseResponse ; Next : TProc ) begin Res . Send ( 'POST request to the root' ) ; end ) THorse . Listen ( 9000 ) ; end . O Horse suporta os seguintes m\u00e9todos de roteamento que correspondem aos m\u00e9todos HTTP: GET, POST, PUT, PATCH, HEAD, DELETE. Existe um m\u00e9todo de roteamento especial, THorse.All, que n\u00e3o \u00e9 derivado de nenhum m\u00e9todo HTTP. Este m\u00e9todo \u00e9 usado para carregar procedures em um caminho para todos os m\u00e9todos de solicita\u00e7\u00e3o. No exemplo a seguir, o manipulador ir\u00e1 ser executado para solicita\u00e7\u00f5es para \u201c/test\u201d se voc\u00ea estiver usando GET, POST, PUT, DELETE, ou qualquer outro m\u00e9todo de solicita\u00e7\u00e3o HTTP que \u00e9 suportado pelo Horse. THorse . All ( '/test' , procedure ( Req : THorseRequest ; Res : THorseResponse ; Next : TProc ) begin Res . Send ( 'Test Response' ) ; end ) ; M\u00e9todos de resposta Os m\u00e9todos do objeto de resposta (res) na seguinte tabela podem enviar uma resposta ao cliente, e finalizar o ciclo solicita\u00e7\u00e3o-resposta. M\u00e9todo Descri\u00e7\u00e3o Res.Download(AFileName) Solicita que seja efetuado o download de um arquivo Res.RedirectTo(ALocation) Redireciona uma solicita\u00e7\u00e3o Res.SendFile(AFileName) Envia um arquivo Res.Send(AContent) Envia uma string Res.Send Envia um objeto Res.Status(AStatus) Configura o c\u00f3digo do status de resposta Res.ContentType(AContentType) Configura o ContentType da resposta","title":"Roteamento"},{"location":"routing/#roteamento","text":"O Roteamento \u00e9 o mecanismo pelo qual as requisi\u00e7\u00f5es s\u00e3o direcionadas para o c\u00f3digo que as trata. Para obter uma introdu\u00e7\u00e3o a roteamento, consulte Roteamento b\u00e1sico . O c\u00f3digo a seguir \u00e9 um exemplo de uma rota muito b\u00e1sica. uses Horse ; begin THorse . Get ( '/ping' , procedure ( Req : THorseRequest ; Res : THorseResponse ; Next : TProc ) begin Res . Send ( 'pong' ) ; end ) ; THorse . Listen ( 9000 ) ; end .","title":"Roteamento"},{"location":"routing/#metodos-de-roteamento","text":"Um m\u00e9todo de roteamento \u00e9 derivado a partir de um dos m\u00e9todos HTTP, e \u00e9 anexado a uma procedure que ir\u00e1 tratar esta requisi\u00e7\u00e3o. o c\u00f3digo a seguir \u00e9 um exemplo de rotas para a raiz do aplicativo que est\u00e3o definidas para os m\u00e9todos GET e POST. uses Horse ; begin THorse . Get ( '/' , procedure ( Req : THorseRequest ; Res : THorseResponse ; Next : TProc ) begin Res . Send ( 'GET request to the root' ) ; end ) ; THorse . Post ( '/' , procedure ( Req : THorseRequest ; Res : THorseResponse ; Next : TProc ) begin Res . Send ( 'POST request to the root' ) ; end ) THorse . Listen ( 9000 ) ; end . O Horse suporta os seguintes m\u00e9todos de roteamento que correspondem aos m\u00e9todos HTTP: GET, POST, PUT, PATCH, HEAD, DELETE. Existe um m\u00e9todo de roteamento especial, THorse.All, que n\u00e3o \u00e9 derivado de nenhum m\u00e9todo HTTP. Este m\u00e9todo \u00e9 usado para carregar procedures em um caminho para todos os m\u00e9todos de solicita\u00e7\u00e3o. No exemplo a seguir, o manipulador ir\u00e1 ser executado para solicita\u00e7\u00f5es para \u201c/test\u201d se voc\u00ea estiver usando GET, POST, PUT, DELETE, ou qualquer outro m\u00e9todo de solicita\u00e7\u00e3o HTTP que \u00e9 suportado pelo Horse. THorse . All ( '/test' , procedure ( Req : THorseRequest ; Res : THorseResponse ; Next : TProc ) begin Res . Send ( 'Test Response' ) ; end ) ;","title":"M\u00e9todos de roteamento"},{"location":"routing/#metodos-de-resposta","text":"Os m\u00e9todos do objeto de resposta (res) na seguinte tabela podem enviar uma resposta ao cliente, e finalizar o ciclo solicita\u00e7\u00e3o-resposta. M\u00e9todo Descri\u00e7\u00e3o Res.Download(AFileName) Solicita que seja efetuado o download de um arquivo Res.RedirectTo(ALocation) Redireciona uma solicita\u00e7\u00e3o Res.SendFile(AFileName) Envia um arquivo Res.Send(AContent) Envia uma string Res.Send Envia um objeto Res.Status(AStatus) Configura o c\u00f3digo do status de resposta Res.ContentType(AContentType) Configura o ContentType da resposta","title":"M\u00e9todos de resposta"}]}