{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Horse What is Horse? Horse is a framework for building web applications. As the main library, it is easy to adopt and integrate with other existing libraries or projects. First Steps The simplest way to test Horse is by installing. Feel free to install it and accompany us with some basic examples. In the topic Installation you will see how to install Horse. Basic Notions At the heart of Horse is a system that allows us to declaratively map HTTP routes using a very simple syntax: uses Horse ; begin THorse . Get ( '/ping' , procedure ( Req : THorseRequest ; Res : THorseResponse ; Next : TProc ) begin Res . Send ( 'pong' ) ; end ) ; THorse . Listen ( 9000 ) ; end . We just created our first Horse server! Ready for More? We introduced Horse briefly - the rest of this guide will delve into other advanced features in a much greater level of detail, so read on! See more at: * Installing Horse. * Creating a Hello world! . * Understanding routing .","title":"Welcome"},{"location":"#horse","text":"","title":"Horse"},{"location":"#what-is-horse","text":"Horse is a framework for building web applications. As the main library, it is easy to adopt and integrate with other existing libraries or projects.","title":"What is Horse?"},{"location":"#first-steps","text":"The simplest way to test Horse is by installing. Feel free to install it and accompany us with some basic examples. In the topic Installation you will see how to install Horse.","title":"First Steps"},{"location":"#basic-notions","text":"At the heart of Horse is a system that allows us to declaratively map HTTP routes using a very simple syntax: uses Horse ; begin THorse . Get ( '/ping' , procedure ( Req : THorseRequest ; Res : THorseResponse ; Next : TProc ) begin Res . Send ( 'pong' ) ; end ) ; THorse . Listen ( 9000 ) ; end . We just created our first Horse server!","title":"Basic Notions"},{"location":"#ready-for-more","text":"We introduced Horse briefly - the rest of this guide will delve into other advanced features in a much greater level of detail, so read on! See more at: * Installing Horse. * Creating a Hello world! . * Understanding routing .","title":"Ready for More?"},{"location":"%23%20Diagramas/","text":"Diagramas graph TD; A-->B; A-->C; B-->D; C-->D; graph LR A[Square Rect] -- Link text --> B((Circle)) A --> C(Round Rect) B --> D{Rhombus} C --> D stateDiagram-v2 [ ] --> Still Still --> [ ] Still --> Moving Moving --> Still Moving --> Crash Crash --> [*] States A state can be declared in multiple ways. The simplest way is to define a state id as a description. stateDiagram-v2 s1 s1 Another way is by using the state keyword with a description as per below: stateDiagram-v2 state \"This is a state description\" as s2 This is a state description Another way to define a state with a description is to define the state id followed by a colon and the description: stateDiagram-v2 s2 : This is a state description This is a state description Transitions Transitions are path/edges when one state passes into another. This is represented using text arrow, \"-->\". When you define a transition between two states and the states are not already defined the undefined states are defined with the id from the transition. You can later add descriptions to states defined this way. stateDiagram-v2 s1 --> s2 s1 v s2 It is possible to add text to a transition. To describe what it represents. stateDiagram-v2 s1 --> s2: A transition s1 | A transition v s2 Start and End There are two special states indicating the start and stop of the diagram. These are written with the [*] syntax and the direction of the transition to it defines it either as a start or a stop state. stateDiagram-v2 [*] --> s1 s1 --> [*] (o)-->s1-->(o)","title":"Diagramas"},{"location":"%23%20Diagramas/#diagramas","text":"graph TD; A-->B; A-->C; B-->D; C-->D; graph LR A[Square Rect] -- Link text --> B((Circle)) A --> C(Round Rect) B --> D{Rhombus} C --> D stateDiagram-v2 [ ] --> Still Still --> [ ] Still --> Moving Moving --> Still Moving --> Crash Crash --> [*] States A state can be declared in multiple ways. The simplest way is to define a state id as a description. stateDiagram-v2 s1 s1 Another way is by using the state keyword with a description as per below: stateDiagram-v2 state \"This is a state description\" as s2 This is a state description Another way to define a state with a description is to define the state id followed by a colon and the description: stateDiagram-v2 s2 : This is a state description This is a state description Transitions Transitions are path/edges when one state passes into another. This is represented using text arrow, \"-->\". When you define a transition between two states and the states are not already defined the undefined states are defined with the id from the transition. You can later add descriptions to states defined this way. stateDiagram-v2 s1 --> s2 s1 v s2 It is possible to add text to a transition. To describe what it represents. stateDiagram-v2 s1 --> s2: A transition s1 | A transition v s2 Start and End There are two special states indicating the start and stop of the diagram. These are written with the [*] syntax and the direction of the transition to it defines it either as a start or a stop state. stateDiagram-v2 [*] --> s1 s1 --> [*] (o)-->s1-->(o)","title":"Diagramas"},{"location":"hello-world/","text":"First create a console project in Delphi or Lazarus, save the project with the name you want (in this example, it will be saved as hashload_horse ). Then install Horse as a dependency on your project, according to the installation guide . After Horse is created and installed in your project, include the following code: uses System . SysUtils , Horse ; const HORSE_PORT = 9000 ; begin THorse . Get ( '/' , procedure ( Req : THorseRequest ; Res : THorseResponse ; Next : TProc ) begin Res . Send ( 'Ol\u00e1, mundo!' ) ; end ) ; THorse . Listen ( HORSE_PORT , procedure ( Horse : THorse ) begin Writeln ( Format ( 'Server is running on %s:%d' , [ Horse . Host , Horse . Port ])) ; end ) end . or uses System . SysUtils , Horse ; const HORSE_PORT = 9000 ; procedure GetHelloWorld ( Req : THorseRequest ; Res : THorseResponse ; Next : TProc ) ; begin Res . Send ( 'Hello world!' ) ; end ; procedure HorseListenCallback ( Horse : THorse ) ; begin Writeln ( Format ( 'Server is running on %s:%d' , [ Horse . Host , Horse . Port ])) ; end ; begin THorse . Get ( '/' , GetHelloWorld ) ; THorse . Listen ( HORSE_PORT , HorseListenCallback ) ; end . The application starts a server and listens for connections on port 9000. The application responds with a Hello, world! on the route (/) to the client that made the request . For all other paths, it will respond with a Not Found message and status code 404 Now, compile and run the application. You will have as a result on the console something like Server is running on 0.0.0.0:9000 Then open a browser, type http://localhost:9000/ in the address bar and browse to view the output. If you were able to view the result in your browser, this is great, your server worked correctly. Now you're ready to evolve on Horse! See more at: * Understanding routing .","title":"hello world"},{"location":"index%20copy/","text":"traduzir esta p\u00e1gina para o portugues Routing determines how the application will respond to a request from a client at an endpoint , which would be the URI and a specific method of the HTTP protocol (POST, PUT, GET, DELETE and so on). On the route, it is possible to have more than one treatment, which will be executed when the route that was requested is the corresponding one. The route has the following structure: THorse . METHOD ( PATH , HANDLER ) ; Where: METHOD is an HTTP request method. PATH it's a path on the server. HANDLER is the method (procedure) that will be executed when the route is matched. The following examples illustrate the definition of simple routes. Reply with \"Hello World!\" to whoever requested ( client who made the request ): THorse . Get ( '/ping' , procedure ( Req : THorseRequest ; Res : THorseResponse ; Next : TProc ) begin Res . Send ( 'Hello World!' ) ; end ) ; Respond to POST request on the root route (/): THorse . Post ( '/' , procedure ( Req : THorseRequest ; Res : THorseResponse ; Next : TProc ) begin Res . Send ( 'Got a POST request' ) ; end ) ; Respond to a PUT request to the /user route: THorse . Put ( '/user' , procedure ( Req : THorseRequest ; Res : THorseResponse ; Next : TProc ) begin Res . Send ( 'Got a PUT request at /user' ) ; end ) ; Respond to a DELETE request to the /user route: THorse . Delete ( '/user' , procedure ( Req : THorseRequest ; Res : THorseResponse ; Next : TProc ) begin Res . Send ( 'Got a DELETE request at /user' ) ; end ) ;","title":"Basic Routing"},{"location":"installation/","text":"Boss The easiest and recommended way to install Horse is with Boss . With it you can manage the version of the dependencies used in your API, in addition to automatically configuring your project's * Library Path *. To perform the installation, simply open the terminal of your choice and enter the following commands: $ boss init $ boss install horse NOTE: it is worth mentioning that the command boss init is to initialize the dependency manager and must be executed only once. If you have already done so, there is no need to do it again. Manual Download the latest version of Horse and include the src/ folder in your project's Library Path . See more at: * Creating a Hello world! .","title":"installation"},{"location":"installation/#boss","text":"The easiest and recommended way to install Horse is with Boss . With it you can manage the version of the dependencies used in your API, in addition to automatically configuring your project's * Library Path *. To perform the installation, simply open the terminal of your choice and enter the following commands: $ boss init $ boss install horse NOTE: it is worth mentioning that the command boss init is to initialize the dependency manager and must be executed only once. If you have already done so, there is no need to do it again.","title":"Boss"},{"location":"installation/#manual","text":"Download the latest version of Horse and include the src/ folder in your project's Library Path . See more at: * Creating a Hello world! .","title":"Manual"},{"location":"routing/","text":"Routing determines how the application will respond to a request from a client at an endpoint , which would be the URI and a specific method of the HTTP protocol (POST, PUT, GET, DELETE and so on). On the route, it is possible to have more than one treatment, which will be executed when the route that was requested is the corresponding one. The route has the following structure: THorse . METHOD ( PATH , HANDLER ) ; Where: METHOD is an HTTP request method. PATH it's a path on the server. HANDLER is the method (procedure) that will be executed when the route is matched. The following examples illustrate the definition of simple routes. Reply with \"Hello World!\" to whoever requested ( client who made the request ): THorse . Get ( '/ping' , procedure ( Req : THorseRequest ; Res : THorseResponse ; Next : TProc ) begin Res . Send ( 'Hello World!' ) ; end ) ; Respond to POST request on the root route (/): THorse . Post ( '/' , procedure ( Req : THorseRequest ; Res : THorseResponse ; Next : TProc ) begin Res . Send ( 'Got a POST request' ) ; end ) ; Respond to a PUT request to the /user route: THorse . Put ( '/user' , procedure ( Req : THorseRequest ; Res : THorseResponse ; Next : TProc ) begin Res . Send ( 'Got a PUT request at /user' ) ; end ) ; Respond to a DELETE request to the /user route: THorse . Delete ( '/user' , procedure ( Req : THorseRequest ; Res : THorseResponse ; Next : TProc ) begin Res . Send ( 'Got a DELETE request at /user' ) ; end ) ;","title":"routing"}]}